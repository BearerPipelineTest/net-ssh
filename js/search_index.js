var search_data = {"index":{"searchIndex":["dl","fiddle","net","ssh","authentication","agent","comment","agenterror","agentnotavailable","certificate","constants","disallowedmethod","ed25519","opensshprivatekeyloader","decrypterror","privkey","pubkey","signingkeyfromfile","ed25519loader","keymanager","keymanagererror","methods","abstract","hostbased","keyboardinteractive","none","password","publickey","pageant","socket","win","libc","ffi","library","session","authenticationfailed","buffer","bufferedio","channelopenfailed","channelrequestfailed","config","connection","channel","constants","eventloop","keepalive","session","nilchannel","stringwithexitstatus","singlesessioneventloop","term","connectiontimeout","disconnect","exception","forwardedbufferedio","hostkeyerror","hostkeymismatch","hostkeyunknown","hostkeys","keyfactory","keytype","opensshprivatekeytype","openssldsakeytype","openssleckeytype","opensslkeytypebase","opensslpkeytype","opensslrsakeytype","knownhosts","loggable","packet","prompt","prompter","proxy","command","connecterror","error","http","https","sslsocketcompatibility","jump","socks4","socks5","unauthorizederror","service","forward","test","channel","extensions","bufferedio","channel","io","classmethods","packetstream","kex","localpacket","packet","remotepacket","script","socket","timeout","transport","algorithms","ctr","cipherfactory","constants","hmac","abstract","md5","openssl","digest","md5_96","none","ripemd160","openssl","digest","sha1","openssl","digest","sha1_96","sha2_256","openssl","digest","sha2_256_96","sha2_256_etm","openssl","digest","sha2_512","openssl","digest","sha2_512_96","sha2_512_etm","openssl","digest","identitycipher","kex","abstract","abstract5656","curve25519sha256","curve25519sha256loader","diffiehellmangroup14sha1","diffiehellmangroup1sha1","diffiehellmangroupexchangesha1","diffiehellmangroupexchangesha256","ecdhsha2nistp256","ecdhsha2nistp384","ecdhsha2nistp521","keyexpander","opensslaesctr","packetstream","serverversion","session","compatibleverifier","state","verifiers","acceptnew","acceptneworlocaltunnel","always","never","version","openssl","bn","pkey","dh","dsa","ec","point","pkey","rsa","string","<=>()","==()","[]()","[]()","[]()","[]()","[]()","[]()","[]=()","[]=()","accept_kexinit()","active?()","active_local_sockets()","active_locals()","active_remote_destinations()","active_remotes()","add()","add()","add()","add_host_key()","add_identity()","add_key_data()","agent()","agent()","allow?()","allowed_packet?()","append()","ask()","assert_scripted()","assign_defaults()","authenticate()","authenticate()","authenticate()","authenticate()","authenticate()","authenticate()","available()","available()","available_for_read?()","block_size()","block_size()","block_size()","build_proxy_command_equivalent()","busy?()","cancel_local()","cancel_local_socket()","cancel_remote()","cleanup()","cleanup()","cleanup_channel()","clear!()","clear!()","client_name()","close()","close()","close()","close()","close()","close_on_error()","closed?()","closed?()","closing?()","compress()","compression?()","compressor()","configuration_for()","configure_client()","configure_server()","connect()","connect!()","connection()","consume!()","curve_name()","curve_name()","curve_name()","curve_name()","debug()","decompress()","decompressor()","decrypt()","decrypt()","default()","default_auth_methods()","default_files()","dependenciesrequiredfored25519()","dependenciesrequiredforx25519()","digest()","digest()","digest_class()","digest_class()","digester()","digester()","digester()","digester()","digester()","digester()","digester()","do_close()","do_eof()","do_extended_data()","do_failure()","do_open_failed()","do_success()","each()","each_identity()","empty?()","empty?()","enabled?()","encrypt()","encrypt()","encrypted_key?()","encrypted_key?()","encrypted_key?()","encrypted_key?()","enqueue()","enqueue_message()","enqueue_packet()","env()","eof!()","eof?()","eof?()","error()","error_classes()","error_classes()","error_classes()","error_classes()","error_classes()","error_classes()","establish_connection()","establish_connection()","etm()","etm()","ev_do_calculate_rw_wait()","ev_do_handle_events()","ev_do_postprocess()","ev_preprocess()","ev_preprocess()","ev_preprocess()","ev_select_and_postprocess()","ev_select_and_postprocess()","exchange_keys()","exchange_keys()","exec()","exec()","exec!()","expand_key()","expandable_default_files()","expect_message()","extended()","extended()","extension_enabled?()","fatal()","fill()","fill()","final()","final()","final_cipher()","fingerprint()","fingerprint()","finish()","for()","forward()","from()","get()","get()","get()","get_lengths()","get_ptr()","getbyte()","getpeername()","gets()","gets_channel_close()","gets_channel_data()","gets_channel_eof()","gets_channel_extended_data()","gets_channel_request()","gets_close()","gets_data()","gets_eof()","gets_exit_status()","gets_extended_data()","hint()","host()","host()","host_as_string()","host_key_format()","host_keys()","hostfiles()","identities()","idle!()","if_needs_rekey?()","increment()","increment_counter!()","info()","initialize_ssh()","initialized?()","inject_remote_delay!()","instantiate!()","interactive?()","interval()","ip()","iv()","iv=()","iv=()","iv=()","iv_len()","iv_len()","keepalive_maxcount()","key()","key=()","key_length()","key_length()","key_length()","keys_for()","known_host_hash?()","length()","listen_to()","load()","load_data_private_key()","load_data_public_key()","load_private_key()","load_public_key()","local()","local?()","local?()","local_closed?()","local_id()","local_socket()","loop()","loop_forever()","lwarn()","mac_length()","mac_length()","malloc_ptr()","match()","max_select_wait_time()","method_missing()","name()","needs_rekey?()","negotiate!()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","next()","next_message()","next_message()","next_packet()","no_keys?()","on_close()","on_data()","on_eof()","on_extended_data()","on_global_request()","on_open_channel()","on_open_failed()","on_process()","on_request()","open()","open()","open()","open()","open()","open()","open()","open_channel()","open_ssl_class()","open_ssl_class()","open_ssl_class()","open_ssl_class()","open_ssl_class()","opens_channel()","options()","padding=()","parse_response()","peer()","peer_ip()","pending?()","pending_write?()","poll_message()","poll_next_packet()","port()","postprocess()","preprocess()","process()","process()","process()","process()","process()","process()","process_only()","public_key()","push()","raiseunlessloaded()","raiseunlessloaded()","read()","read()","read()","read()","read()","read()","read()","read()","read!()","read_all()","read_available()","read_bignum()","read_bool()","read_buffer()","read_byte()","read_certblob()","read_int64()","read_key()","read_keyblob()","read_keyblob()","read_keyblob()","read_long()","read_private_keyblob()","read_string()","read_to()","readpartial()","recv()","register()","register()","register_channel_request()","registered_channel_requests()","rekey!()","rekey!()","rekey_as_needed()","remainder_as_buffer()","remember_host!()","remote()","remote?()","remote?()","remote_closed!()","remote_closed?()","remote_id()","remote_to()","remove_all_identities()","remove_identity()","request_pty()","reset()","reset()","reset()","reset!()","reset!()","search_for()","search_in()","select_for_read?()","select_for_test()","send()","send()","send_as_needed()","send_channel_request()","send_data()","send_data_for_test()","send_global_request()","send_message()","send_message()","send_message()","send_packet()","send_pending()","send_pending()","send_query()","sends()","sends_channel_close()","sends_channel_data()","sends_channel_eof()","sends_channel_request()","sends_channel_request_pty()","sends_close()","sends_data()","sends_eof()","sends_exec()","sends_request_pty()","sends_subsystem()","service_request()","session_id()","set()","set_ptr_data()","setbyte()","should_send?()","shutdown!()","shutdown!()","sign()","sign()","sign()","sign!()","signature_valid?()","socket()","ssh_do_sign()","ssh_do_sign()","ssh_do_sign()","ssh_do_sign()","ssh_do_sign()","ssh_do_verify()","ssh_do_verify()","ssh_do_verify()","ssh_do_verify()","ssh_do_verify()","ssh_signature_type()","ssh_signature_type()","ssh_signature_type()","ssh_signature_type()","ssh_signature_type()","ssh_signature_type()","ssh_type()","ssh_type()","ssh_type()","ssh_type()","ssh_type()","ssh_type()","ssh_type()","start()","start()","start()","stop_listening_to()","story()","subsystem()","success()","supported?()","test_available_for_read?()","test_enqueue_packet()","test_poll_next_packet()","to_blob()","to_blob()","to_blob()","to_blob()","to_blob()","to_blob()","to_blob()","to_i()","to_pem()","to_pem()","to_s()","to_s()","to_s()","to_ssh()","translate()","transport()","types()","update()","update()","update_cipher()","use_agent=()","use_agent?()","userauth_request()","valid?()","verify()","verify()","verify()","verify()","verify()","verify_signature()","verify_signature()","verify_signature()","verify_signature()","wait()","wait()","wait_for_pending_sends()","with_test_extension()","write()","write()","write_bignum()","write_bool()","write_byte()","write_int64()","write_key()","write_long()","write_moved()","write_mstring()","write_string()","xor!()","changes","license","readme","thanks"],"longSearchIndex":["dl","dl::fiddle","net","net::ssh","net::ssh::authentication","net::ssh::authentication::agent","net::ssh::authentication::agent::comment","net::ssh::authentication::agenterror","net::ssh::authentication::agentnotavailable","net::ssh::authentication::certificate","net::ssh::authentication::constants","net::ssh::authentication::disallowedmethod","net::ssh::authentication::ed25519","net::ssh::authentication::ed25519::opensshprivatekeyloader","net::ssh::authentication::ed25519::opensshprivatekeyloader::decrypterror","net::ssh::authentication::ed25519::privkey","net::ssh::authentication::ed25519::pubkey","net::ssh::authentication::ed25519::signingkeyfromfile","net::ssh::authentication::ed25519loader","net::ssh::authentication::keymanager","net::ssh::authentication::keymanagererror","net::ssh::authentication::methods","net::ssh::authentication::methods::abstract","net::ssh::authentication::methods::hostbased","net::ssh::authentication::methods::keyboardinteractive","net::ssh::authentication::methods::none","net::ssh::authentication::methods::password","net::ssh::authentication::methods::publickey","net::ssh::authentication::pageant","net::ssh::authentication::pageant::socket","net::ssh::authentication::pageant::win","net::ssh::authentication::pageant::win::libc","net::ssh::authentication::pageant::win::libc::ffi","net::ssh::authentication::pageant::win::libc::ffi::library","net::ssh::authentication::session","net::ssh::authenticationfailed","net::ssh::buffer","net::ssh::bufferedio","net::ssh::channelopenfailed","net::ssh::channelrequestfailed","net::ssh::config","net::ssh::connection","net::ssh::connection::channel","net::ssh::connection::constants","net::ssh::connection::eventloop","net::ssh::connection::keepalive","net::ssh::connection::session","net::ssh::connection::session::nilchannel","net::ssh::connection::session::stringwithexitstatus","net::ssh::connection::singlesessioneventloop","net::ssh::connection::term","net::ssh::connectiontimeout","net::ssh::disconnect","net::ssh::exception","net::ssh::forwardedbufferedio","net::ssh::hostkeyerror","net::ssh::hostkeymismatch","net::ssh::hostkeyunknown","net::ssh::hostkeys","net::ssh::keyfactory","net::ssh::keyfactory::keytype","net::ssh::keyfactory::opensshprivatekeytype","net::ssh::keyfactory::openssldsakeytype","net::ssh::keyfactory::openssleckeytype","net::ssh::keyfactory::opensslkeytypebase","net::ssh::keyfactory::opensslpkeytype","net::ssh::keyfactory::opensslrsakeytype","net::ssh::knownhosts","net::ssh::loggable","net::ssh::packet","net::ssh::prompt","net::ssh::prompt::prompter","net::ssh::proxy","net::ssh::proxy::command","net::ssh::proxy::connecterror","net::ssh::proxy::error","net::ssh::proxy::http","net::ssh::proxy::https","net::ssh::proxy::https::sslsocketcompatibility","net::ssh::proxy::jump","net::ssh::proxy::socks4","net::ssh::proxy::socks5","net::ssh::proxy::unauthorizederror","net::ssh::service","net::ssh::service::forward","net::ssh::test","net::ssh::test::channel","net::ssh::test::extensions","net::ssh::test::extensions::bufferedio","net::ssh::test::extensions::channel","net::ssh::test::extensions::io","net::ssh::test::extensions::io::classmethods","net::ssh::test::extensions::packetstream","net::ssh::test::kex","net::ssh::test::localpacket","net::ssh::test::packet","net::ssh::test::remotepacket","net::ssh::test::script","net::ssh::test::socket","net::ssh::timeout","net::ssh::transport","net::ssh::transport::algorithms","net::ssh::transport::ctr","net::ssh::transport::cipherfactory","net::ssh::transport::constants","net::ssh::transport::hmac","net::ssh::transport::hmac::abstract","net::ssh::transport::hmac::md5","net::ssh::transport::hmac::md5::openssl","net::ssh::transport::hmac::md5::openssl::digest","net::ssh::transport::hmac::md5_96","net::ssh::transport::hmac::none","net::ssh::transport::hmac::ripemd160","net::ssh::transport::hmac::ripemd160::openssl","net::ssh::transport::hmac::ripemd160::openssl::digest","net::ssh::transport::hmac::sha1","net::ssh::transport::hmac::sha1::openssl","net::ssh::transport::hmac::sha1::openssl::digest","net::ssh::transport::hmac::sha1_96","net::ssh::transport::hmac::sha2_256","net::ssh::transport::hmac::sha2_256::openssl","net::ssh::transport::hmac::sha2_256::openssl::digest","net::ssh::transport::hmac::sha2_256_96","net::ssh::transport::hmac::sha2_256_etm","net::ssh::transport::hmac::sha2_256_etm::openssl","net::ssh::transport::hmac::sha2_256_etm::openssl::digest","net::ssh::transport::hmac::sha2_512","net::ssh::transport::hmac::sha2_512::openssl","net::ssh::transport::hmac::sha2_512::openssl::digest","net::ssh::transport::hmac::sha2_512_96","net::ssh::transport::hmac::sha2_512_etm","net::ssh::transport::hmac::sha2_512_etm::openssl","net::ssh::transport::hmac::sha2_512_etm::openssl::digest","net::ssh::transport::identitycipher","net::ssh::transport::kex","net::ssh::transport::kex::abstract","net::ssh::transport::kex::abstract5656","net::ssh::transport::kex::curve25519sha256","net::ssh::transport::kex::curve25519sha256loader","net::ssh::transport::kex::diffiehellmangroup14sha1","net::ssh::transport::kex::diffiehellmangroup1sha1","net::ssh::transport::kex::diffiehellmangroupexchangesha1","net::ssh::transport::kex::diffiehellmangroupexchangesha256","net::ssh::transport::kex::ecdhsha2nistp256","net::ssh::transport::kex::ecdhsha2nistp384","net::ssh::transport::kex::ecdhsha2nistp521","net::ssh::transport::keyexpander","net::ssh::transport::opensslaesctr","net::ssh::transport::packetstream","net::ssh::transport::serverversion","net::ssh::transport::session","net::ssh::transport::session::compatibleverifier","net::ssh::transport::state","net::ssh::verifiers","net::ssh::verifiers::acceptnew","net::ssh::verifiers::acceptneworlocaltunnel","net::ssh::verifiers::always","net::ssh::verifiers::never","net::ssh::version","openssl","openssl::bn","openssl::pkey","openssl::pkey::dh","openssl::pkey::dsa","openssl::pkey::ec","openssl::pkey::ec::point","openssl::pkey::pkey","openssl::pkey::rsa","string","net::ssh::version#<=>()","net::ssh::buffer#==()","net::ssh::connection::channel#[]()","net::ssh::connection::session#[]()","net::ssh::hostkeyerror#[]()","net::ssh::packet#[]()","net::ssh::transport::algorithms#[]()","net::ssh::version::[]()","net::ssh::connection::channel#[]=()","net::ssh::connection::session#[]=()","net::ssh::transport::algorithms#accept_kexinit()","net::ssh::connection::channel#active?()","net::ssh::service::forward#active_local_sockets()","net::ssh::service::forward#active_locals()","net::ssh::service::forward#active_remote_destinations()","net::ssh::service::forward#active_remotes()","net::ssh::authentication::keymanager#add()","net::ssh::knownhosts::add()","net::ssh::knownhosts#add()","net::ssh::hostkeys#add_host_key()","net::ssh::authentication::agent#add_identity()","net::ssh::authentication::keymanager#add_key_data()","net::ssh::authentication::keymanager#agent()","net::ssh::service::forward#agent()","net::ssh::transport::algorithms#allow?()","net::ssh::transport::algorithms::allowed_packet?()","net::ssh::buffer#append()","net::ssh::prompt::prompter#ask()","net::ssh::test#assert_scripted()","net::ssh::assign_defaults()","net::ssh::authentication::methods::hostbased#authenticate()","net::ssh::authentication::methods::keyboardinteractive#authenticate()","net::ssh::authentication::methods::none#authenticate()","net::ssh::authentication::methods::password#authenticate()","net::ssh::authentication::methods::publickey#authenticate()","net::ssh::authentication::session#authenticate()","net::ssh::buffer#available()","net::ssh::bufferedio#available()","net::ssh::transport::packetstream#available_for_read?()","net::ssh::transport::identitycipher::block_size()","net::ssh::transport::opensslaesctr#block_size()","net::ssh::transport::opensslaesctr::block_size()","net::ssh::proxy::jump#build_proxy_command_equivalent()","net::ssh::connection::session#busy?()","net::ssh::service::forward#cancel_local()","net::ssh::service::forward#cancel_local_socket()","net::ssh::service::forward#cancel_remote()","net::ssh::transport::packetstream#cleanup()","net::ssh::transport::state#cleanup()","net::ssh::connection::session#cleanup_channel()","net::ssh::authentication::keymanager#clear!()","net::ssh::buffer#clear!()","net::ssh::transport::packetstream#client_name()","net::ssh::authentication::agent#close()","net::ssh::authentication::pageant::socket#close()","net::ssh::connection::channel#close()","net::ssh::connection::session#close()","net::ssh::transport::session#close()","net::ssh::proxy::command#close_on_error()","net::ssh::connection::session#closed?()","net::ssh::transport::session#closed?()","net::ssh::connection::channel#closing?()","net::ssh::transport::state#compress()","net::ssh::transport::state#compression?()","net::ssh::transport::state#compressor()","net::ssh::configuration_for()","net::ssh::transport::session#configure_client()","net::ssh::transport::session#configure_server()","net::ssh::authentication::agent::connect()","net::ssh::authentication::agent#connect!()","net::ssh::test#connection()","net::ssh::buffer#consume!()","net::ssh::transport::kex::abstract5656#curve_name()","net::ssh::transport::kex::ecdhsha2nistp256#curve_name()","net::ssh::transport::kex::ecdhsha2nistp384#curve_name()","net::ssh::transport::kex::ecdhsha2nistp521#curve_name()","net::ssh::loggable#debug()","net::ssh::transport::state#decompress()","net::ssh::transport::state#decompressor()","net::ssh::transport::ctr#decrypt()","net::ssh::transport::identitycipher::decrypt()","net::ssh::prompt::default()","net::ssh::config::default_auth_methods()","net::ssh::config::default_files()","net::ssh::authentication::ed25519loader::dependenciesrequiredfored25519()","net::ssh::transport::kex::curve25519sha256loader::dependenciesrequiredforx25519()","net::ssh::transport::hmac::abstract#digest()","net::ssh::transport::hmac::none#digest()","net::ssh::transport::hmac::abstract#digest_class()","net::ssh::transport::hmac::abstract::digest_class()","net::ssh::transport::kex::abstract#digester()","net::ssh::transport::kex::curve25519sha256#digester()","net::ssh::transport::kex::diffiehellmangroup1sha1#digester()","net::ssh::transport::kex::diffiehellmangroupexchangesha256#digester()","net::ssh::transport::kex::ecdhsha2nistp256#digester()","net::ssh::transport::kex::ecdhsha2nistp384#digester()","net::ssh::transport::kex::ecdhsha2nistp521#digester()","net::ssh::connection::channel#do_close()","net::ssh::connection::channel#do_eof()","net::ssh::connection::channel#do_extended_data()","net::ssh::connection::channel#do_failure()","net::ssh::connection::channel#do_open_failed()","net::ssh::connection::channel#do_success()","net::ssh::hostkeys#each()","net::ssh::authentication::keymanager#each_identity()","net::ssh::buffer#empty?()","net::ssh::hostkeys#empty?()","net::ssh::connection::keepalive#enabled?()","net::ssh::transport::ctr#encrypt()","net::ssh::transport::identitycipher::encrypt()","net::ssh::authentication::ed25519::opensshprivatekeyloader::decrypterror#encrypted_key?()","net::ssh::keyfactory::keytype::encrypted_key?()","net::ssh::keyfactory::opensshprivatekeytype::encrypted_key?()","net::ssh::keyfactory::opensslkeytypebase::encrypted_key?()","net::ssh::bufferedio#enqueue()","net::ssh::transport::session#enqueue_message()","net::ssh::transport::packetstream#enqueue_packet()","net::ssh::connection::channel#env()","net::ssh::connection::channel#eof!()","net::ssh::buffer#eof?()","net::ssh::connection::channel#eof?()","net::ssh::loggable#error()","net::ssh::keyfactory::keytype::error_classes()","net::ssh::keyfactory::opensshprivatekeytype::error_classes()","net::ssh::keyfactory::openssldsakeytype::error_classes()","net::ssh::keyfactory::openssleckeytype::error_classes()","net::ssh::keyfactory::opensslpkeytype::error_classes()","net::ssh::keyfactory::opensslrsakeytype::error_classes()","net::ssh::proxy::http#establish_connection()","net::ssh::proxy::https#establish_connection()","net::ssh::transport::hmac::abstract#etm()","net::ssh::transport::hmac::abstract::etm()","net::ssh::connection::session#ev_do_calculate_rw_wait()","net::ssh::connection::session#ev_do_handle_events()","net::ssh::connection::session#ev_do_postprocess()","net::ssh::connection::eventloop#ev_preprocess()","net::ssh::connection::session#ev_preprocess()","net::ssh::connection::singlesessioneventloop#ev_preprocess()","net::ssh::connection::eventloop#ev_select_and_postprocess()","net::ssh::connection::singlesessioneventloop#ev_select_and_postprocess()","net::ssh::test::kex#exchange_keys()","net::ssh::transport::kex::abstract#exchange_keys()","net::ssh::connection::channel#exec()","net::ssh::connection::session#exec()","net::ssh::connection::session#exec!()","net::ssh::transport::keyexpander::expand_key()","net::ssh::config::expandable_default_files()","net::ssh::authentication::session#expect_message()","net::ssh::transport::ctr::extended()","net::ssh::transport::packetstream::extended()","net::ssh::test::extensions::io::extension_enabled?()","net::ssh::loggable#fatal()","net::ssh::bufferedio#fill()","net::ssh::forwardedbufferedio#fill()","net::ssh::transport::ctr#final()","net::ssh::transport::identitycipher::final()","net::ssh::transport::state#final_cipher()","net::ssh::authentication::certificate#fingerprint()","net::ssh::hostkeyerror#fingerprint()","net::ssh::authentication::keymanager#finish()","net::ssh::config::for()","net::ssh::connection::session#forward()","net::ssh::buffer::from()","net::ssh::keyfactory::get()","net::ssh::transport::cipherfactory::get()","net::ssh::transport::hmac::get()","net::ssh::transport::cipherfactory::get_lengths()","net::ssh::authentication::pageant::win::get_ptr()","string#getbyte()","net::ssh::test::socket#getpeername()","net::ssh::test::script#gets()","net::ssh::test::script#gets_channel_close()","net::ssh::test::script#gets_channel_data()","net::ssh::test::script#gets_channel_eof()","net::ssh::test::script#gets_channel_extended_data()","net::ssh::test::script#gets_channel_request()","net::ssh::test::channel#gets_close()","net::ssh::test::channel#gets_data()","net::ssh::test::channel#gets_eof()","net::ssh::test::channel#gets_exit_status()","net::ssh::test::channel#gets_extended_data()","net::ssh::transport::session#hint()","net::ssh::connection::session#host()","net::ssh::hostkeyerror#host()","net::ssh::transport::session#host_as_string()","net::ssh::transport::algorithms#host_key_format()","net::ssh::transport::session#host_keys()","net::ssh::knownhosts::hostfiles()","net::ssh::authentication::agent#identities()","net::ssh::test::extensions::packetstream#idle!()","net::ssh::transport::packetstream#if_needs_rekey?()","net::ssh::transport::state#increment()","net::ssh::transport::ctr#increment_counter!()","net::ssh::loggable#info()","net::ssh::transport::packetstream#initialize_ssh()","net::ssh::transport::algorithms#initialized?()","net::ssh::test::channel#inject_remote_delay!()","net::ssh::test::packet#instantiate!()","net::ssh::authentication::methods::keyboardinteractive#interactive?()","net::ssh::connection::keepalive#interval()","net::ssh::hostkeyerror#ip()","net::ssh::transport::ctr#iv()","net::ssh::transport::ctr#iv=()","net::ssh::transport::identitycipher::iv=()","net::ssh::transport::opensslaesctr#iv=()","net::ssh::transport::ctr#iv_len()","net::ssh::transport::identitycipher::iv_len()","net::ssh::connection::keepalive#keepalive_maxcount()","net::ssh::hostkeyerror#key()","net::ssh::transport::hmac::abstract#key=()","net::ssh::transport::hmac::key_length()","net::ssh::transport::hmac::abstract#key_length()","net::ssh::transport::hmac::abstract::key_length()","net::ssh::knownhosts#keys_for()","net::ssh::knownhosts#known_host_hash?()","net::ssh::buffer#length()","net::ssh::connection::session#listen_to()","net::ssh::config::load()","net::ssh::keyfactory::load_data_private_key()","net::ssh::keyfactory::load_data_public_key()","net::ssh::keyfactory::load_private_key()","net::ssh::keyfactory::load_public_key()","net::ssh::service::forward#local()","net::ssh::test::localpacket#local?()","net::ssh::test::packet#local?()","net::ssh::connection::channel#local_closed?()","net::ssh::test::channel#local_id()","net::ssh::service::forward#local_socket()","net::ssh::connection::session#loop()","net::ssh::connection::session#loop_forever()","net::ssh::loggable#lwarn()","net::ssh::transport::hmac::abstract::mac_length()","net::ssh::transport::hmac::abstract#mac_length()","net::ssh::authentication::pageant::win::malloc_ptr()","net::ssh::knownhosts#match()","net::ssh::connection::session#max_select_wait_time()","net::ssh::connection::session::nilchannel#method_missing()","net::ssh::transport::identitycipher::name()","net::ssh::transport::state#needs_rekey?()","net::ssh::authentication::agent#negotiate!()","net::ssh::authentication::agent::new()","net::ssh::authentication::ed25519::opensshprivatekeyloader::decrypterror::new()","net::ssh::authentication::ed25519::privkey::new()","net::ssh::authentication::ed25519::pubkey::new()","net::ssh::authentication::ed25519::signingkeyfromfile::new()","net::ssh::authentication::keymanager::new()","net::ssh::authentication::methods::abstract::new()","net::ssh::authentication::pageant::socket::new()","net::ssh::authentication::session::new()","net::ssh::buffer::new()","net::ssh::channelopenfailed::new()","net::ssh::connection::channel::new()","net::ssh::connection::eventloop::new()","net::ssh::connection::keepalive::new()","net::ssh::connection::session::new()","net::ssh::connection::session::nilchannel::new()","net::ssh::connection::session::stringwithexitstatus::new()","net::ssh::hostkeys::new()","net::ssh::knownhosts::new()","net::ssh::packet::new()","net::ssh::prompt::new()","net::ssh::prompt::prompter::new()","net::ssh::proxy::command::new()","net::ssh::proxy::http::new()","net::ssh::proxy::https::new()","net::ssh::proxy::jump::new()","net::ssh::proxy::socks4::new()","net::ssh::proxy::socks5::new()","net::ssh::service::forward::new()","net::ssh::test::channel::new()","net::ssh::test::kex::new()","net::ssh::test::localpacket::new()","net::ssh::test::packet::new()","net::ssh::test::script::new()","net::ssh::test::socket::new()","net::ssh::transport::algorithms::new()","net::ssh::transport::hmac::abstract::new()","net::ssh::transport::kex::abstract::new()","net::ssh::transport::opensslaesctr::new()","net::ssh::transport::serverversion::new()","net::ssh::transport::session::new()","net::ssh::transport::session::compatibleverifier::new()","net::ssh::transport::state::new()","net::ssh::version::new()","net::ssh::test::script#next()","net::ssh::authentication::session#next_message()","net::ssh::transport::session#next_message()","net::ssh::transport::packetstream#next_packet()","net::ssh::authentication::keymanager#no_keys?()","net::ssh::connection::channel#on_close()","net::ssh::connection::channel#on_data()","net::ssh::connection::channel#on_eof()","net::ssh::connection::channel#on_extended_data()","net::ssh::connection::session#on_global_request()","net::ssh::connection::session#on_open_channel()","net::ssh::connection::channel#on_open_failed()","net::ssh::connection::channel#on_process()","net::ssh::connection::channel#on_request()","net::ssh::authentication::pageant::socket::open()","net::ssh::proxy::command#open()","net::ssh::proxy::http#open()","net::ssh::proxy::jump#open()","net::ssh::proxy::socks4#open()","net::ssh::proxy::socks5#open()","net::ssh::test::socket#open()","net::ssh::connection::session#open_channel()","net::ssh::keyfactory::openssldsakeytype::open_ssl_class()","net::ssh::keyfactory::openssleckeytype::open_ssl_class()","net::ssh::keyfactory::opensslkeytypebase::open_ssl_class()","net::ssh::keyfactory::opensslpkeytype::open_ssl_class()","net::ssh::keyfactory::opensslrsakeytype::open_ssl_class()","net::ssh::test::script#opens_channel()","net::ssh::connection::keepalive#options()","net::ssh::transport::ctr#padding=()","net::ssh::proxy::http#parse_response()","net::ssh::transport::session#peer()","net::ssh::transport::packetstream#peer_ip()","net::ssh::transport::algorithms#pending?()","net::ssh::bufferedio#pending_write?()","net::ssh::transport::session#poll_message()","net::ssh::transport::packetstream#poll_next_packet()","net::ssh::hostkeyerror#port()","net::ssh::connection::session#postprocess()","net::ssh::connection::session#preprocess()","net::ssh::connection::channel#process()","net::ssh::connection::eventloop#process()","net::ssh::connection::session#process()","net::ssh::test::localpacket#process()","net::ssh::test::remotepacket#process()","net::ssh::test::script#process()","net::ssh::connection::eventloop#process_only()","net::ssh::authentication::ed25519::privkey#public_key()","net::ssh::transport::session#push()","net::ssh::authentication::ed25519loader::raiseunlessloaded()","net::ssh::transport::kex::curve25519sha256loader::raiseunlessloaded()","net::ssh::authentication::ed25519::opensshprivatekeyloader::read()","net::ssh::authentication::ed25519::privkey::read()","net::ssh::authentication::pageant::socket#read()","net::ssh::buffer#read()","net::ssh::keyfactory::keytype::read()","net::ssh::keyfactory::opensshprivatekeytype::read()","net::ssh::keyfactory::opensslkeytypebase::read()","net::ssh::keyfactory::opensslpkeytype::read()","net::ssh::buffer#read!()","net::ssh::buffer#read_all()","net::ssh::bufferedio#read_available()","net::ssh::buffer#read_bignum()","net::ssh::buffer#read_bool()","net::ssh::buffer#read_buffer()","net::ssh::buffer#read_byte()","net::ssh::authentication::certificate::read_certblob()","net::ssh::buffer#read_int64()","net::ssh::buffer#read_key()","net::ssh::authentication::ed25519::pubkey::read_keyblob()","net::ssh::buffer#read_keyblob()","openssl::pkey::ec::read_keyblob()","net::ssh::buffer#read_long()","net::ssh::buffer#read_private_keyblob()","net::ssh::buffer#read_string()","net::ssh::buffer#read_to()","net::ssh::test::socket#readpartial()","net::ssh::test::socket#recv()","net::ssh::connection::eventloop#register()","net::ssh::packet::register()","net::ssh::test::packet::register_channel_request()","net::ssh::test::packet::registered_channel_requests()","net::ssh::transport::algorithms#rekey!()","net::ssh::transport::session#rekey!()","net::ssh::transport::session#rekey_as_needed()","net::ssh::buffer#remainder_as_buffer()","net::ssh::hostkeyerror#remember_host!()","net::ssh::service::forward#remote()","net::ssh::test::packet#remote?()","net::ssh::test::remotepacket#remote?()","net::ssh::connection::channel#remote_closed!()","net::ssh::connection::channel#remote_closed?()","net::ssh::test::channel#remote_id()","net::ssh::service::forward#remote_to()","net::ssh::authentication::agent#remove_all_identities()","net::ssh::authentication::agent#remove_identity()","net::ssh::connection::channel#request_pty()","net::ssh::transport::ctr#reset()","net::ssh::transport::identitycipher::reset()","net::ssh::transport::opensslaesctr#reset()","net::ssh::buffer#reset!()","net::ssh::transport::state#reset!()","net::ssh::knownhosts::search_for()","net::ssh::knownhosts::search_in()","net::ssh::test::extensions::bufferedio#select_for_read?()","net::ssh::test::extensions::io::classmethods#select_for_test()","net::ssh::authentication::pageant::socket#send()","net::ssh::proxy::https::sslsocketcompatibility#send()","net::ssh::connection::keepalive#send_as_needed()","net::ssh::connection::channel#send_channel_request()","net::ssh::connection::channel#send_data()","net::ssh::test::extensions::channel#send_data_for_test()","net::ssh::connection::session#send_global_request()","net::ssh::authentication::methods::abstract#send_message()","net::ssh::connection::session#send_message()","net::ssh::transport::session#send_message()","net::ssh::transport::packetstream#send_packet()","net::ssh::bufferedio#send_pending()","net::ssh::forwardedbufferedio#send_pending()","net::ssh::authentication::pageant::socket#send_query()","net::ssh::test::script#sends()","net::ssh::test::script#sends_channel_close()","net::ssh::test::script#sends_channel_data()","net::ssh::test::script#sends_channel_eof()","net::ssh::test::script#sends_channel_request()","net::ssh::test::script#sends_channel_request_pty()","net::ssh::test::channel#sends_close()","net::ssh::test::channel#sends_data()","net::ssh::test::channel#sends_eof()","net::ssh::test::channel#sends_exec()","net::ssh::test::channel#sends_request_pty()","net::ssh::test::channel#sends_subsystem()","net::ssh::transport::session#service_request()","net::ssh::authentication::methods::abstract#session_id()","net::ssh::transport::state#set()","net::ssh::authentication::pageant::win::set_ptr_data()","string#setbyte()","net::ssh::connection::keepalive#should_send?()","net::ssh::connection::session#shutdown!()","net::ssh::transport::session#shutdown!()","net::ssh::authentication::agent#sign()","net::ssh::authentication::certificate#sign()","net::ssh::authentication::keymanager#sign()","net::ssh::authentication::certificate#sign!()","net::ssh::authentication::certificate#signature_valid?()","net::ssh::test#socket()","net::ssh::authentication::certificate#ssh_do_sign()","net::ssh::authentication::ed25519::privkey#ssh_do_sign()","openssl::pkey::dsa#ssh_do_sign()","openssl::pkey::ec#ssh_do_sign()","openssl::pkey::rsa#ssh_do_sign()","net::ssh::authentication::certificate#ssh_do_verify()","net::ssh::authentication::ed25519::pubkey#ssh_do_verify()","openssl::pkey::dsa#ssh_do_verify()","openssl::pkey::ec#ssh_do_verify()","openssl::pkey::rsa#ssh_do_verify()","net::ssh::authentication::certificate#ssh_signature_type()","net::ssh::authentication::ed25519::privkey#ssh_signature_type()","net::ssh::authentication::ed25519::pubkey#ssh_signature_type()","openssl::pkey::dsa#ssh_signature_type()","openssl::pkey::ec#ssh_signature_type()","openssl::pkey::rsa#ssh_signature_type()","net::ssh::authentication::certificate#ssh_type()","net::ssh::authentication::ed25519::privkey#ssh_type()","net::ssh::authentication::ed25519::pubkey#ssh_type()","openssl::pkey::dsa#ssh_type()","openssl::pkey::ec#ssh_type()","openssl::pkey::ec::point#ssh_type()","openssl::pkey::rsa#ssh_type()","net::ssh::start()","net::ssh::prompt#start()","net::ssh::transport::algorithms#start()","net::ssh::connection::session#stop_listening_to()","net::ssh::test#story()","net::ssh::connection::channel#subsystem()","net::ssh::prompt::prompter#success()","net::ssh::transport::cipherfactory::supported?()","net::ssh::test::extensions::packetstream#test_available_for_read?()","net::ssh::test::extensions::packetstream#test_enqueue_packet()","net::ssh::test::extensions::packetstream#test_poll_next_packet()","net::ssh::authentication::certificate#to_blob()","net::ssh::authentication::ed25519::privkey#to_blob()","net::ssh::authentication::ed25519::pubkey#to_blob()","openssl::pkey::dsa#to_blob()","openssl::pkey::ec#to_blob()","openssl::pkey::ec::point#to_blob()","openssl::pkey::rsa#to_blob()","net::ssh::version#to_i()","net::ssh::authentication::certificate#to_pem()","net::ssh::authentication::ed25519::pubkey#to_pem()","net::ssh::buffer#to_s()","net::ssh::test::remotepacket#to_s()","net::ssh::version#to_s()","openssl::bn#to_ssh()","net::ssh::config::translate()","net::ssh::test#transport()","net::ssh::test::packet#types()","net::ssh::transport::ctr#update()","net::ssh::transport::identitycipher::update()","net::ssh::transport::state#update_cipher()","net::ssh::authentication::keymanager#use_agent=()","net::ssh::authentication::keymanager#use_agent?()","net::ssh::authentication::methods::abstract#userauth_request()","openssl::pkey::dh#valid?()","net::ssh::transport::session::compatibleverifier#verify()","net::ssh::verifiers::acceptnew#verify()","net::ssh::verifiers::acceptneworlocaltunnel#verify()","net::ssh::verifiers::always#verify()","net::ssh::verifiers::never#verify()","net::ssh::transport::session::compatibleverifier#verify_signature()","net::ssh::verifiers::acceptnew#verify_signature()","net::ssh::verifiers::always#verify_signature()","net::ssh::verifiers::never#verify_signature()","net::ssh::connection::channel#wait()","net::ssh::transport::session#wait()","net::ssh::bufferedio#wait_for_pending_sends()","net::ssh::test::extensions::io::with_test_extension()","net::ssh::buffer#write()","net::ssh::test::socket#write()","net::ssh::buffer#write_bignum()","net::ssh::buffer#write_bool()","net::ssh::buffer#write_byte()","net::ssh::buffer#write_int64()","net::ssh::buffer#write_key()","net::ssh::buffer#write_long()","net::ssh::buffer#write_moved()","net::ssh::buffer#write_mstring()","net::ssh::buffer#write_string()","net::ssh::transport::ctr#xor!()","","","",""],"info":[["DL","","DL.html","","<p>For now map DL to Fiddler versus updating all the code below\n"],["DL::Fiddle","","DL/Fiddle.html","",""],["Net","","Net.html","",""],["Net::SSH","","Net/SSH.html","","<p>Net::SSH is a library for interacting, programmatically, with remote\nprocesses via the SSH2 protocol. …\n"],["Net::SSH::Authentication","","Net/SSH/Authentication.html","",""],["Net::SSH::Authentication::Agent","","Net/SSH/Authentication/Agent.html","","<p>This class implements a simple client for the ssh-agent protocol. It does\nnot implement any specific …\n"],["Net::SSH::Authentication::Agent::Comment","","Net/SSH/Authentication/Agent/Comment.html","","<p>A simple module for extending keys, to allow comments to be specified for\nthem.\n"],["Net::SSH::Authentication::AgentError","","Net/SSH/Authentication/AgentError.html","","<p>Class for representing agent-specific errors.\n"],["Net::SSH::Authentication::AgentNotAvailable","","Net/SSH/Authentication/AgentNotAvailable.html","","<p>An exception for indicating that the SSH agent is not available.\n"],["Net::SSH::Authentication::Certificate","","Net/SSH/Authentication/Certificate.html","","<p>Class for representing an SSH certificate.\n<p>cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/usr.bin/ssh/PROTOCOL.certkeys?rev=1.10&content-type=text/plain\n…\n"],["Net::SSH::Authentication::Constants","","Net/SSH/Authentication/Constants.html","","<p>Describes the constants used by the Net::SSH::Authentication components of\nthe Net::SSH library. Individual …\n"],["Net::SSH::Authentication::DisallowedMethod","","Net/SSH/Authentication/DisallowedMethod.html","","<p>Raised if the current authentication method is not allowed\n"],["Net::SSH::Authentication::ED25519","","Net/SSH/Authentication/ED25519.html","",""],["Net::SSH::Authentication::ED25519::OpenSSHPrivateKeyLoader","","Net/SSH/Authentication/ED25519/OpenSSHPrivateKeyLoader.html","",""],["Net::SSH::Authentication::ED25519::OpenSSHPrivateKeyLoader::DecryptError","","Net/SSH/Authentication/ED25519/OpenSSHPrivateKeyLoader/DecryptError.html","",""],["Net::SSH::Authentication::ED25519::PrivKey","","Net/SSH/Authentication/ED25519/PrivKey.html","",""],["Net::SSH::Authentication::ED25519::PubKey","","Net/SSH/Authentication/ED25519/PubKey.html","",""],["Net::SSH::Authentication::ED25519::SigningKeyFromFile","","Net/SSH/Authentication/ED25519/SigningKeyFromFile.html","",""],["Net::SSH::Authentication::ED25519Loader","","Net/SSH/Authentication/ED25519Loader.html","","<p>Loads ED25519 support which requires optinal dependecies like rbnacl,\nbcrypt_pbkdf\n"],["Net::SSH::Authentication::KeyManager","","Net/SSH/Authentication/KeyManager.html","","<p>This class encapsulates all operations done by clients on a user&#39;s\nprivate keys. In practice, the …\n"],["Net::SSH::Authentication::KeyManagerError","","Net/SSH/Authentication/KeyManagerError.html","","<p>A trivial exception class used to report errors in the key manager.\n"],["Net::SSH::Authentication::Methods","","Net/SSH/Authentication/Methods.html","",""],["Net::SSH::Authentication::Methods::Abstract","","Net/SSH/Authentication/Methods/Abstract.html","","<p>The base class of all user authentication methods. It provides a few bits\nof common functionality.\n"],["Net::SSH::Authentication::Methods::Hostbased","","Net/SSH/Authentication/Methods/Hostbased.html","","<p>Implements the host-based SSH authentication method.\n"],["Net::SSH::Authentication::Methods::KeyboardInteractive","","Net/SSH/Authentication/Methods/KeyboardInteractive.html","","<p>Implements the “keyboard-interactive” SSH authentication method.\n"],["Net::SSH::Authentication::Methods::None","","Net/SSH/Authentication/Methods/None.html","","<p>Implements the “none” SSH authentication method.\n"],["Net::SSH::Authentication::Methods::Password","","Net/SSH/Authentication/Methods/Password.html","","<p>Implements the “password” SSH authentication method.\n"],["Net::SSH::Authentication::Methods::Publickey","","Net/SSH/Authentication/Methods/Publickey.html","","<p>Implements the “publickey” SSH authentication method.\n"],["Net::SSH::Authentication::Pageant","","Net/SSH/Authentication/Pageant.html","","<p>This module encapsulates the implementation of a socket factory that uses\nthe PuTTY “pageant” …\n"],["Net::SSH::Authentication::Pageant::Socket","","Net/SSH/Authentication/Pageant/Socket.html","","<p>This is the pseudo-socket implementation that mimics the interface of a\nsocket, translating each request …\n"],["Net::SSH::Authentication::Pageant::Win","","Net/SSH/Authentication/Pageant/Win.html","","<p>The definition of the Windows methods and data structures used in\ncommunicating with the pageant process. …\n"],["Net::SSH::Authentication::Pageant::Win::LibC","","Net/SSH/Authentication/Pageant/Win/LibC.html","",""],["Net::SSH::Authentication::Pageant::Win::LibC::FFI","","Net/SSH/Authentication/Pageant/Win/LibC/FFI.html","",""],["Net::SSH::Authentication::Pageant::Win::LibC::FFI::Library","","Net/SSH/Authentication/Pageant/Win/LibC/FFI/Library.html","",""],["Net::SSH::Authentication::Session","","Net/SSH/Authentication/Session.html","","<p>Represents an authentication session. It manages the authentication of a\nuser over an established connection …\n"],["Net::SSH::AuthenticationFailed","","Net/SSH/AuthenticationFailed.html","","<p>This exception is raised when authentication fails (whether it be public\nkey authentication, password …\n"],["Net::SSH::Buffer","","Net/SSH/Buffer.html","","<p>Net::SSH::Buffer is a flexible class for building and parsing binary data\npackets. It provides a stream-like …\n"],["Net::SSH::BufferedIo","","Net/SSH/BufferedIo.html","","<p>This module is used to extend sockets and other IO objects, to allow them\nto be buffered for both read …\n"],["Net::SSH::ChannelOpenFailed","","Net/SSH/ChannelOpenFailed.html","","<p>This is exception is primarily used internally, but if you have a channel\nopen handler (see Net::SSH::Connection::Session#on_open_channel …\n"],["Net::SSH::ChannelRequestFailed","","Net/SSH/ChannelRequestFailed.html","","<p>This exception is primarily used internally, but if you have a channel\nrequest handler (see Net::SSH::Connection::Channel#on_request …\n"],["Net::SSH::Config","","Net/SSH/Config.html","","<p>The Net::SSH::Config class is used to parse OpenSSH configuration files,\nand translates that syntax into …\n"],["Net::SSH::Connection","","Net/SSH/Connection.html","",""],["Net::SSH::Connection::Channel","","Net/SSH/Connection/Channel.html","","<p>The channel abstraction. Multiple “channels” can be multiplexed onto a\nsingle SSH channel, …\n"],["Net::SSH::Connection::Constants","","Net/SSH/Connection/Constants.html","","<p>Definitions of constants that are specific to the connection layer of the\nSSH protocol.\n"],["Net::SSH::Connection::EventLoop","","Net/SSH/Connection/EventLoop.html","","<p>EventLoop can be shared across multiple sessions\n<p>one issue is with blocks passed to loop, etc. they should …\n"],["Net::SSH::Connection::Keepalive","","Net/SSH/Connection/Keepalive.html","",""],["Net::SSH::Connection::Session","","Net/SSH/Connection/Session.html","","<p>A session class representing the connection service running on top of the\nSSH transport layer. It manages …\n"],["Net::SSH::Connection::Session::NilChannel","","Net/SSH/Connection/Session/NilChannel.html","",""],["Net::SSH::Connection::Session::StringWithExitstatus","","Net/SSH/Connection/Session/StringWithExitstatus.html","",""],["Net::SSH::Connection::SingleSessionEventLoop","","Net/SSH/Connection/SingleSessionEventLoop.html","","<p>optimized version for a single session\n"],["Net::SSH::Connection::Term","","Net/SSH/Connection/Term.html","","<p>These constants are used when requesting a pseudo-terminal (via\nNet::SSH::Connection::Channel#request_pty …\n"],["Net::SSH::ConnectionTimeout","","Net/SSH/ConnectionTimeout.html","","<p>This exception is raised when a connection attempt times out.\n"],["Net::SSH::Disconnect","","Net/SSH/Disconnect.html","","<p>This exception is raised when the remote host has disconnected\nunexpectedly.\n"],["Net::SSH::Exception","","Net/SSH/Exception.html","","<p>A general exception class, to act as the ancestor of all other Net::SSH\nexception classes.\n"],["Net::SSH::ForwardedBufferedIo","","Net/SSH/ForwardedBufferedIo.html","","<p>Fixes for two issues by Miklós Fazekas:\n\n<pre>* if client closes a forwarded connection, but the server is\n ...</pre>\n"],["Net::SSH::HostKeyError","","Net/SSH/HostKeyError.html","","<p>Base class for host key exceptions. When rescuing this exception, you can\ninspect the key fingerprint …\n"],["Net::SSH::HostKeyMismatch","","Net/SSH/HostKeyMismatch.html","","<p>Raised when the cached key for a particular host does not match the key\ngiven by the host, which can …\n"],["Net::SSH::HostKeyUnknown","","Net/SSH/HostKeyUnknown.html","","<p>Raised when there is no cached key for a particular host, which probably\nmeans that the host has simply …\n"],["Net::SSH::HostKeys","","Net/SSH/HostKeys.html","","<p>Represents the result of a search in known hosts see search_for\n"],["Net::SSH::KeyFactory","","Net/SSH/KeyFactory.html","","<p>A factory class for returning new Key classes. It is used for obtaining\nOpenSSL key instances via their …\n"],["Net::SSH::KeyFactory::KeyType","","Net/SSH/KeyFactory/KeyType.html","","<p>rubocop:disable Style/Documentation, Lint/DuplicateMethods\n"],["Net::SSH::KeyFactory::OpenSSHPrivateKeyType","","Net/SSH/KeyFactory/OpenSSHPrivateKeyType.html","",""],["Net::SSH::KeyFactory::OpenSSLDSAKeyType","","Net/SSH/KeyFactory/OpenSSLDSAKeyType.html","",""],["Net::SSH::KeyFactory::OpenSSLECKeyType","","Net/SSH/KeyFactory/OpenSSLECKeyType.html","",""],["Net::SSH::KeyFactory::OpenSSLKeyTypeBase","","Net/SSH/KeyFactory/OpenSSLKeyTypeBase.html","",""],["Net::SSH::KeyFactory::OpenSSLPKeyType","","Net/SSH/KeyFactory/OpenSSLPKeyType.html","",""],["Net::SSH::KeyFactory::OpenSSLRSAKeyType","","Net/SSH/KeyFactory/OpenSSLRSAKeyType.html","",""],["Net::SSH::KnownHosts","","Net/SSH/KnownHosts.html","","<p>Searches an OpenSSH-style known-host file for a given host, and returns all\nmatching keys. This is used …\n"],["Net::SSH::Loggable","","Net/SSH/Loggable.html","","<p>A simple module to make logging easier to deal with. It assumes that the\nlogger instance (if not nil) …\n"],["Net::SSH::Packet","","Net/SSH/Packet.html","","<p>A specialization of Buffer that knows the format of certain common packet\ntypes. It auto-parses those …\n"],["Net::SSH::Prompt","","Net/SSH/Prompt.html","","<p>Default prompt implementation, called for asking password from user. It\nwill never be instantiated directly, …\n"],["Net::SSH::Prompt::Prompter","","Net/SSH/Prompt/Prompter.html","","<p>default prompt object implementation. More sophisticated implemenetations\nmight implement caching.\n"],["Net::SSH::Proxy","","Net/SSH/Proxy.html","",""],["Net::SSH::Proxy::Command","","Net/SSH/Proxy/Command.html","","<p>An implementation of a command proxy. To use it, instantiate it, then pass\nthe instantiated object via …\n"],["Net::SSH::Proxy::ConnectError","","Net/SSH/Proxy/ConnectError.html","","<p>Used for reporting proxy connection errors.\n"],["Net::SSH::Proxy::Error","","Net/SSH/Proxy/Error.html","","<p>A general exception class for all Proxy errors.\n"],["Net::SSH::Proxy::HTTP","","Net/SSH/Proxy/HTTP.html","","<p>An implementation of an HTTP proxy. To use it, instantiate it, then pass\nthe instantiated object via …\n"],["Net::SSH::Proxy::HTTPS","","Net/SSH/Proxy/HTTPS.html","","<p>A specialization of the HTTP proxy which encrypts the whole connection\nusing OpenSSL. This has the advantage …\n"],["Net::SSH::Proxy::HTTPS::SSLSocketCompatibility","","Net/SSH/Proxy/HTTPS/SSLSocketCompatibility.html","","<p>Shim to make OpenSSL::SSL::SSLSocket behave like a regular TCPSocket for\nall intents and purposes of …\n"],["Net::SSH::Proxy::Jump","","Net/SSH/Proxy/Jump.html","","<p>An implementation of a jump proxy. To use it, instantiate it, then pass the\ninstantiated object via the …\n"],["Net::SSH::Proxy::SOCKS4","","Net/SSH/Proxy/SOCKS4.html","","<p>An implementation of a SOCKS4 proxy. To use it, instantiate it, then pass\nthe instantiated object via …\n"],["Net::SSH::Proxy::SOCKS5","","Net/SSH/Proxy/SOCKS5.html","","<p>An implementation of a SOCKS5 proxy. To use it, instantiate it, then pass\nthe instantiated object via …\n"],["Net::SSH::Proxy::UnauthorizedError","","Net/SSH/Proxy/UnauthorizedError.html","","<p>Used when the server doesn&#39;t recognize the user&#39;s credentials.\n"],["Net::SSH::Service","","Net/SSH/Service.html","",""],["Net::SSH::Service::Forward","","Net/SSH/Service/Forward.html","","<p>This class implements various port forwarding services for use by Net::SSH\nclients. The Forward class …\n"],["Net::SSH::Test","","Net/SSH/Test.html","","<p>This module may be used in unit tests, for when you want to test that your\nSSH state machines are really …\n"],["Net::SSH::Test::Channel","","Net/SSH/Test/Channel.html","","<p>A mock channel, used for scripting actions in tests. It wraps a\nNet::SSH::Test::Script instance, and …\n"],["Net::SSH::Test::Extensions","","Net/SSH/Test/Extensions.html","","<p>A collection of modules used to extend/override the default behavior of\nNet::SSH internals for ease of …\n"],["Net::SSH::Test::Extensions::BufferedIo","","Net/SSH/Test/Extensions/BufferedIo.html","","<p>An extension to Net::SSH::BufferedIo (assumes that the underlying IO is\nactually a StringIO). Facilitates …\n"],["Net::SSH::Test::Extensions::Channel","","Net/SSH/Test/Extensions/Channel.html","","<p>An extension to Net::SSH::Connection::Channel. Facilitates unit testing.\n"],["Net::SSH::Test::Extensions::IO","","Net/SSH/Test/Extensions/IO.html","","<p>An extension to the built-in ::IO class. Simply redefines IO.select so that\nit can be scripted in Net::SSH …\n"],["Net::SSH::Test::Extensions::IO::ClassMethods","","Net/SSH/Test/Extensions/IO/ClassMethods.html","",""],["Net::SSH::Test::Extensions::PacketStream","","Net/SSH/Test/Extensions/PacketStream.html","","<p>An extension to Net::SSH::Transport::PacketStream (assumes that the\nunderlying IO is actually a StringIO …\n"],["Net::SSH::Test::Kex","","Net/SSH/Test/Kex.html","","<p>An implementation of a key-exchange strategy specifically for unit tests.\n(This strategy would never …\n"],["Net::SSH::Test::LocalPacket","","Net/SSH/Test/LocalPacket.html","","<p>This is a specialization of Net::SSH::Test::Packet for representing mock\npackets that are sent from the …\n"],["Net::SSH::Test::Packet","","Net/SSH/Test/Packet.html","","<p>This is an abstract class, not to be instantiated directly, subclassed by\nNet::SSH::Test::LocalPacket …\n"],["Net::SSH::Test::RemotePacket","","Net/SSH/Test/RemotePacket.html","","<p>This is a specialization of Net::SSH::Test::Packet for representing mock\npackets that are received by …\n"],["Net::SSH::Test::Script","","Net/SSH/Test/Script.html","","<p>Represents a sequence of scripted events that identify the behavior that a\ntest expects. Methods named …\n"],["Net::SSH::Test::Socket","","Net/SSH/Test/Socket.html","","<p>A mock socket implementation for use in testing. It implements the minimum\nnecessary interface for interacting …\n"],["Net::SSH::Timeout","","Net/SSH/Timeout.html","","<p>This exception is raised when the remote host has disconnected/ timeouted\nunexpectedly.\n"],["Net::SSH::Transport","","Net/SSH/Transport.html","",""],["Net::SSH::Transport::Algorithms","","Net/SSH/Transport/Algorithms.html","","<p>Implements the higher-level logic behind an SSH key-exchange. It handles\nboth the initial exchange, as …\n"],["Net::SSH::Transport::CTR","","Net/SSH/Transport/CTR.html","","<p>Pure-Ruby implementation of Stateful Decryption Counter(SDCTR) Mode for\nBlock Ciphers. See RFC4344 for …\n"],["Net::SSH::Transport::CipherFactory","","Net/SSH/Transport/CipherFactory.html","","<p>Implements a factory of OpenSSL cipher algorithms.\n"],["Net::SSH::Transport::Constants","","Net/SSH/Transport/Constants.html","",""],["Net::SSH::Transport::HMAC","","Net/SSH/Transport/HMAC.html","","<p>Implements a simple factory interface for fetching hmac implementations, or\nfor finding the key lengths …\n"],["Net::SSH::Transport::HMAC::Abstract","","Net/SSH/Transport/HMAC/Abstract.html","","<p>The base class of all OpenSSL-based HMAC algorithm wrappers.\n"],["Net::SSH::Transport::HMAC::MD5","","Net/SSH/Transport/HMAC/MD5.html","","<p>The MD5 HMAC algorithm.\n"],["Net::SSH::Transport::HMAC::MD5::OpenSSL","","Net/SSH/Transport/HMAC/MD5/OpenSSL.html","",""],["Net::SSH::Transport::HMAC::MD5::OpenSSL::Digest","","Net/SSH/Transport/HMAC/MD5/OpenSSL/Digest.html","",""],["Net::SSH::Transport::HMAC::MD5_96","","Net/SSH/Transport/HMAC/MD5_96.html","","<p>The MD5-96 HMAC algorithm. This returns only the first 12 bytes of the\ndigest.\n"],["Net::SSH::Transport::HMAC::None","","Net/SSH/Transport/HMAC/None.html","","<p>The “none” algorithm. This has a key and mac length of 0.\n"],["Net::SSH::Transport::HMAC::RIPEMD160","","Net/SSH/Transport/HMAC/RIPEMD160.html","","<p>The RIPEMD-160 HMAC algorithm. This has a mac and key length of 20, and\nuses the RIPEMD-160 digest algorithm. …\n"],["Net::SSH::Transport::HMAC::RIPEMD160::OpenSSL","","Net/SSH/Transport/HMAC/RIPEMD160/OpenSSL.html","",""],["Net::SSH::Transport::HMAC::RIPEMD160::OpenSSL::Digest","","Net/SSH/Transport/HMAC/RIPEMD160/OpenSSL/Digest.html","",""],["Net::SSH::Transport::HMAC::SHA1","","Net/SSH/Transport/HMAC/SHA1.html","","<p>The SHA1 HMAC algorithm. This has a mac and key length of 20, and uses the\nSHA1 digest algorithm.\n"],["Net::SSH::Transport::HMAC::SHA1::OpenSSL","","Net/SSH/Transport/HMAC/SHA1/OpenSSL.html","",""],["Net::SSH::Transport::HMAC::SHA1::OpenSSL::Digest","","Net/SSH/Transport/HMAC/SHA1/OpenSSL/Digest.html","",""],["Net::SSH::Transport::HMAC::SHA1_96","","Net/SSH/Transport/HMAC/SHA1_96.html","","<p>The SHA1-96 HMAC algorithm. This returns only the first 12 bytes of the\ndigest.\n"],["Net::SSH::Transport::HMAC::SHA2_256","","Net/SSH/Transport/HMAC/SHA2_256.html","","<p>The SHA-256 HMAC algorithm. This has a mac and key length of 32, and uses\nthe SHA-256 digest algorithm. …\n"],["Net::SSH::Transport::HMAC::SHA2_256::OpenSSL","","Net/SSH/Transport/HMAC/SHA2_256/OpenSSL.html","",""],["Net::SSH::Transport::HMAC::SHA2_256::OpenSSL::Digest","","Net/SSH/Transport/HMAC/SHA2_256/OpenSSL/Digest.html","",""],["Net::SSH::Transport::HMAC::SHA2_256_96","","Net/SSH/Transport/HMAC/SHA2_256_96.html","","<p>The SHA256-96 HMAC algorithm. This returns only the first 12 bytes of the\ndigest.\n"],["Net::SSH::Transport::HMAC::SHA2_256_Etm","","Net/SSH/Transport/HMAC/SHA2_256_Etm.html","","<p>The SHA-256 Encrypt-Then-Mac HMAC algorithm. This has a mac and key length\nof 32, and uses the SHA-256 …\n"],["Net::SSH::Transport::HMAC::SHA2_256_Etm::OpenSSL","","Net/SSH/Transport/HMAC/SHA2_256_Etm/OpenSSL.html","",""],["Net::SSH::Transport::HMAC::SHA2_256_Etm::OpenSSL::Digest","","Net/SSH/Transport/HMAC/SHA2_256_Etm/OpenSSL/Digest.html","",""],["Net::SSH::Transport::HMAC::SHA2_512","","Net/SSH/Transport/HMAC/SHA2_512.html","","<p>The SHA-512 HMAC algorithm. This has a mac and key length of 64, and uses\nthe SHA-512 digest algorithm. …\n"],["Net::SSH::Transport::HMAC::SHA2_512::OpenSSL","","Net/SSH/Transport/HMAC/SHA2_512/OpenSSL.html","",""],["Net::SSH::Transport::HMAC::SHA2_512::OpenSSL::Digest","","Net/SSH/Transport/HMAC/SHA2_512/OpenSSL/Digest.html","",""],["Net::SSH::Transport::HMAC::SHA2_512_96","","Net/SSH/Transport/HMAC/SHA2_512_96.html","","<p>The SHA2-512-96 HMAC algorithm. This returns only the first 12 bytes of the\ndigest.\n"],["Net::SSH::Transport::HMAC::SHA2_512_Etm","","Net/SSH/Transport/HMAC/SHA2_512_Etm.html","","<p>The SHA-512 Encrypt-Then-Mac HMAC algorithm. This has a mac and key length\nof 64, and uses the SHA-512 …\n"],["Net::SSH::Transport::HMAC::SHA2_512_Etm::OpenSSL","","Net/SSH/Transport/HMAC/SHA2_512_Etm/OpenSSL.html","",""],["Net::SSH::Transport::HMAC::SHA2_512_Etm::OpenSSL::Digest","","Net/SSH/Transport/HMAC/SHA2_512_Etm/OpenSSL/Digest.html","",""],["Net::SSH::Transport::IdentityCipher","","Net/SSH/Transport/IdentityCipher.html","","<p>A cipher that does nothing but pass the data through, unchanged. This keeps\nthings in the code nice and …\n"],["Net::SSH::Transport::Kex","","Net/SSH/Transport/Kex.html","",""],["Net::SSH::Transport::Kex::Abstract","","Net/SSH/Transport/Kex/Abstract.html","","<p>Abstract class that implement Diffie-Hellman Key Exchange See\ntools.ietf.org/html/rfc4253#page-21\n"],["Net::SSH::Transport::Kex::Abstract5656","","Net/SSH/Transport/Kex/Abstract5656.html","","<p>Implement key-exchange algorithm from Elliptic Curve Algorithm Integration\nin the Secure Shell Transport …\n"],["Net::SSH::Transport::Kex::Curve25519Sha256","","Net/SSH/Transport/Kex/Curve25519Sha256.html","","<p>A key-exchange service implementing the “curve25519-sha256@libssh.org”\nkey-exchange algorithm. …\n"],["Net::SSH::Transport::Kex::Curve25519Sha256Loader","","Net/SSH/Transport/Kex/Curve25519Sha256Loader.html","","<p>Loads Curve25519Sha256 support which requires optinal dependencies\n"],["Net::SSH::Transport::Kex::DiffieHellmanGroup14SHA1","","Net/SSH/Transport/Kex/DiffieHellmanGroup14SHA1.html","","<p>A key-exchange service implementing the “diffie-hellman-group14-sha1”\nkey-exchange algorithm. …\n"],["Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1","","Net/SSH/Transport/Kex/DiffieHellmanGroup1SHA1.html","","<p>A key-exchange service implementing the “diffie-hellman-group1-sha1”\nkey-exchange algorithm. …\n"],["Net::SSH::Transport::Kex::DiffieHellmanGroupExchangeSHA1","","Net/SSH/Transport/Kex/DiffieHellmanGroupExchangeSHA1.html","","<p>A key-exchange service implementing the\n“diffie-hellman-group-exchange-sha1” key-exchange algorithm. …\n"],["Net::SSH::Transport::Kex::DiffieHellmanGroupExchangeSHA256","","Net/SSH/Transport/Kex/DiffieHellmanGroupExchangeSHA256.html","","<p>A key-exchange service implementing the\n“diffie-hellman-group-exchange-sha256” key-exchange …\n"],["Net::SSH::Transport::Kex::EcdhSHA2NistP256","","Net/SSH/Transport/Kex/EcdhSHA2NistP256.html","","<p>A key-exchange service implementing the “ecdh-sha2-nistp256” key-exchange\nalgorithm. (defined …\n"],["Net::SSH::Transport::Kex::EcdhSHA2NistP384","","Net/SSH/Transport/Kex/EcdhSHA2NistP384.html","","<p>A key-exchange service implementing the “ecdh-sha2-nistp256” key-exchange\nalgorithm. (defined …\n"],["Net::SSH::Transport::Kex::EcdhSHA2NistP521","","Net/SSH/Transport/Kex/EcdhSHA2NistP521.html","","<p>A key-exchange service implementing the “ecdh-sha2-nistp521” key-exchange\nalgorithm. (defined …\n"],["Net::SSH::Transport::KeyExpander","","Net/SSH/Transport/KeyExpander.html","",""],["Net::SSH::Transport::OpenSSLAESCTR","","Net/SSH/Transport/OpenSSLAESCTR.html","",""],["Net::SSH::Transport::PacketStream","","Net/SSH/Transport/PacketStream.html","","<p>A module that builds additional functionality onto the Net::SSH::BufferedIo\nmodule. It adds SSH encryption, …\n"],["Net::SSH::Transport::ServerVersion","","Net/SSH/Transport/ServerVersion.html","","<p>Negotiates the SSH protocol version and trades information about server and\nclient. This is never used …\n"],["Net::SSH::Transport::Session","","Net/SSH/Transport/Session.html","","<p>The transport layer represents the lowest level of the SSH protocol, and\nimplements basic message exchanging …\n"],["Net::SSH::Transport::Session::CompatibleVerifier","","Net/SSH/Transport/Session/CompatibleVerifier.html","","<p>Compatibility verifier which allows users to keep using custom verifier\ncode without adding new :verify_signature …\n"],["Net::SSH::Transport::State","","Net/SSH/Transport/State.html","","<p>Encapsulates state information about one end of an SSH connection. Such\nstate includes the packet sequence …\n"],["Net::SSH::Verifiers","","Net/SSH/Verifiers.html","",""],["Net::SSH::Verifiers::AcceptNew","","Net/SSH/Verifiers/AcceptNew.html","","<p>Does a strict host verification, looking the server up in the known host\nfiles to see if a key has already …\n"],["Net::SSH::Verifiers::AcceptNewOrLocalTunnel","","Net/SSH/Verifiers/AcceptNewOrLocalTunnel.html","","<p>Basically the same as the AcceptNew verifier, but does not try to actually\nverify a connection if the …\n"],["Net::SSH::Verifiers::Always","","Net/SSH/Verifiers/Always.html","","<p>Does a strict host verification, looking the server up in the known host\nfiles to see if a key has already …\n"],["Net::SSH::Verifiers::Never","","Net/SSH/Verifiers/Never.html","","<p>This host key verifier simply allows every key it sees, without any\nverification. This is simple, but …\n"],["Net::SSH::Version","","Net/SSH/Version.html","","<p>A class for describing the current version of a library. The version\nconsists of three parts: the <code>major</code> …\n"],["OpenSSL","","OpenSSL.html","",""],["OpenSSL::BN","","OpenSSL/BN.html","","<p>This class is originally defined in the OpenSSL module. As needed, methods\nhave been added to it by the …\n"],["OpenSSL::PKey","","OpenSSL/PKey.html","",""],["OpenSSL::PKey::DH","","OpenSSL/PKey/DH.html","","<p>This class is originally defined in the OpenSSL module. As needed, methods\nhave been added to it by the …\n"],["OpenSSL::PKey::DSA","","OpenSSL/PKey/DSA.html","","<p>This class is originally defined in the OpenSSL module. As needed, methods\nhave been added to it by the …\n"],["OpenSSL::PKey::EC","","OpenSSL/PKey/EC.html","","<p>This class is originally defined in the OpenSSL module. As needed, methods\nhave been added to it by the …\n"],["OpenSSL::PKey::EC::Point","","OpenSSL/PKey/EC/Point.html","",""],["OpenSSL::PKey::PKey","","OpenSSL/PKey/PKey.html","",""],["OpenSSL::PKey::RSA","","OpenSSL/PKey/RSA.html","","<p>This class is originally defined in the OpenSSL module. As needed, methods\nhave been added to it by the …\n"],["String","","String.html","",""],["<=>","Net::SSH::Version","Net/SSH/Version.html#method-i-3C-3D-3E","(version)","<p>Compare this version to the given <code>version</code> object.\n"],["==","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-3D-3D","(buffer)","<p>Compares the contents of the two buffers, returning <code>true</code> only\nif they are identical in size and content. …\n"],["[]","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-5B-5D","(name)","<p>A shortcut for accessing properties of the channel (see #properties).\n"],["[]","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-5B-5D","(key)","<p>Retrieves a custom property from this instance. This can be used to store\nadditional state in applications …\n"],["[]","Net::SSH::HostKeyError","Net/SSH/HostKeyError.html#method-i-5B-5D","(key)","<p>An accessor for getting at the data that was used to look up the host (see\nalso #fingerprint, #host, …\n"],["[]","Net::SSH::Packet","Net/SSH/Packet.html#method-i-5B-5D","(name)","<p>Access one of the auto-parsed fields by name. Raises an error if no element\nby the given name exists. …\n"],["[]","Net::SSH::Transport::Algorithms","Net/SSH/Transport/Algorithms.html#method-i-5B-5D","(key)","<p>A convenience method for accessing the list of preferred types for a\nspecific algorithm (see #algorithms …\n"],["[]","Net::SSH::Version","Net/SSH/Version.html#method-c-5B-5D","(major, minor, tiny, pre = nil)","<p>A convenience method for instantiating a new Version instance with the\ngiven <code>major</code>, <code>minor</code>, and <code>tiny</code>\ncomponents. …\n"],["[]=","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-5B-5D-3D","(name, value)","<p>A shortcut for setting properties of the channel (see #properties).\n"],["[]=","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-5B-5D-3D","(key, value)","<p>Sets a custom property for this instance.\n"],["accept_kexinit","Net::SSH::Transport::Algorithms","Net/SSH/Transport/Algorithms.html#method-i-accept_kexinit","(packet)","<p>Called by the transport layer when a KEXINIT packet is received, indicating\nthat the server wants to …\n"],["active?","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-active-3F","()","<p>Returns true if the channel exists in the channel list of the session, and\nfalse otherwise. This can …\n"],["active_local_sockets","Net::SSH::Service::Forward","Net/SSH/Service/Forward.html#method-i-active_local_sockets","()","<p>Returns a list of all active locally forwarded sockets. The returned value\nis an array of Unix domain …\n"],["active_locals","Net::SSH::Service::Forward","Net/SSH/Service/Forward.html#method-i-active_locals","()","<p>Returns a list of all active locally forwarded ports. The returned value is\nan array of arrays, where …\n"],["active_remote_destinations","Net::SSH::Service::Forward","Net/SSH/Service/Forward.html#method-i-active_remote_destinations","()","<p>Returns all active remote forwarded ports and where they forward to. The\nreturned value is a hash from …\n"],["active_remotes","Net::SSH::Service::Forward","Net/SSH/Service/Forward.html#method-i-active_remotes","()","<p>Returns all active forwarded remote ports. The returned value is an array\nof two-element tuples, where …\n"],["add","Net::SSH::Authentication::KeyManager","Net/SSH/Authentication/KeyManager.html#method-i-add","(key_file)","<p>Add the given key_file to the list of key files that will be used.\n"],["add","Net::SSH::KnownHosts","Net/SSH/KnownHosts.html#method-c-add","(host, key, options={})","<p>Looks in all user known host files (see KnownHosts.hostfiles) and tries to\nadd an entry for the given …\n"],["add","Net::SSH::KnownHosts","Net/SSH/KnownHosts.html#method-i-add","(host, key)","<p>Tries to append an entry to the current source file for the given host and\nkey. If it is unable to (because …\n"],["add_host_key","Net::SSH::HostKeys","Net/SSH/HostKeys.html#method-i-add_host_key","(key)",""],["add_identity","Net::SSH::Authentication::Agent","Net/SSH/Authentication/Agent.html#method-i-add_identity","(priv_key, comment, lifetime: nil, confirm: false)","<p>Adds the private key with comment to the agent. If lifetime is given, the\nkey will automatically be removed …\n"],["add_key_data","Net::SSH::Authentication::KeyManager","Net/SSH/Authentication/KeyManager.html#method-i-add_key_data","(key_data_)","<p>Add the given key_file to the list of keys that will be used.\n"],["agent","Net::SSH::Authentication::KeyManager","Net/SSH/Authentication/KeyManager.html#method-i-agent","()","<p>Returns an Agent instance to use for communicating with an SSH agent\nprocess. Returns nil if use of an …\n"],["agent","Net::SSH::Service::Forward","Net/SSH/Service/Forward.html#method-i-agent","(channel)","<p>Enables SSH agent forwarding on the given channel. The forwarded agent will\nremain active even after …\n"],["allow?","Net::SSH::Transport::Algorithms","Net/SSH/Transport/Algorithms.html#method-i-allow-3F","(packet)","<p>Returns true if no exchange is pending, and otherwise returns true or false\ndepending on whether the …\n"],["allowed_packet?","Net::SSH::Transport::Algorithms","Net/SSH/Transport/Algorithms.html#method-c-allowed_packet-3F","(packet)","<p>Returns true if the given packet can be processed during a key-exchange.\n"],["append","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-append","(text)","<p>Appends the given text to the end of the buffer. Does not alter the read\nposition. Returns the buffer …\n"],["ask","Net::SSH::Prompt::Prompter","Net/SSH/Prompt/Prompter.html#method-i-ask","(prompt, echo=true)","<p>ask input from user, a prompter might ask for multiple inputs (like user\nand password) in a single session. …\n"],["assert_scripted","Net::SSH::Test","Net/SSH/Test.html#method-i-assert_scripted","()","<p>First asserts that a story has been described (see #story). Then yields,\nand then asserts that all items …\n"],["assign_defaults","Net::SSH","Net/SSH.html#method-c-assign_defaults","(options)",""],["authenticate","Net::SSH::Authentication::Methods::Hostbased","Net/SSH/Authentication/Methods/Hostbased.html#method-i-authenticate","(next_service, username, password=nil)","<p>Attempts to perform host-based authorization of the user by trying all\nknown keys.\n"],["authenticate","Net::SSH::Authentication::Methods::KeyboardInteractive","Net/SSH/Authentication/Methods/KeyboardInteractive.html#method-i-authenticate","(next_service, username, password=nil)","<p>Attempt to authenticate the given user for the given service.\n"],["authenticate","Net::SSH::Authentication::Methods::None","Net/SSH/Authentication/Methods/None.html#method-i-authenticate","(next_service, user=\"\", password=\"\")","<p>Attempt to authenticate as “none”\n"],["authenticate","Net::SSH::Authentication::Methods::Password","Net/SSH/Authentication/Methods/Password.html#method-i-authenticate","(next_service, username, password=nil)","<p>Attempt to authenticate the given user for the given service. If the\npassword parameter is nil, this …\n"],["authenticate","Net::SSH::Authentication::Methods::Publickey","Net/SSH/Authentication/Methods/Publickey.html#method-i-authenticate","(next_service, username, password=nil)","<p>Attempts to perform public-key authentication for the given username,\ntrying each identity known to the …\n"],["authenticate","Net::SSH::Authentication::Session","Net/SSH/Authentication/Session.html#method-i-authenticate","(next_service, username, password=nil)","<p>Attempts to authenticate the given user, in preparation for the next\nservice request. Returns true if …\n"],["available","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-available","()","<p>Returns the number of bytes available to be read (e.g., how many bytes\nremain between the current position …\n"],["available","Net::SSH::BufferedIo","Net/SSH/BufferedIo.html#method-i-available","()","<p>Returns the number of bytes available to be read from the input buffer.\n(See #read_available.)\n"],["available_for_read?","Net::SSH::Transport::PacketStream","Net/SSH/Transport/PacketStream.html#method-i-available_for_read-3F","()","<p>Returns true if the IO is available for reading, and false otherwise.\n"],["block_size","Net::SSH::Transport::IdentityCipher","Net/SSH/Transport/IdentityCipher.html#method-c-block_size","()","<p>A default block size of 8 is required by the SSH2 protocol.\n"],["block_size","Net::SSH::Transport::OpenSSLAESCTR","Net/SSH/Transport/OpenSSLAESCTR.html#method-i-block_size","()",""],["block_size","Net::SSH::Transport::OpenSSLAESCTR","Net/SSH/Transport/OpenSSLAESCTR.html#method-c-block_size","()",""],["build_proxy_command_equivalent","Net::SSH::Proxy::Jump","Net/SSH/Proxy/Jump.html#method-i-build_proxy_command_equivalent","(connection_options = nil)","<p>We cannot build the ProxyCommand template until we know if the :config\noption was specified during `Net::SSH.start`. …\n"],["busy?","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-busy-3F","(include_invisible=false)","<p>Returns <code>true</code> if there are any channels currently active on\nthis session. By default, this will not include …\n"],["cancel_local","Net::SSH::Service::Forward","Net/SSH/Service/Forward.html#method-i-cancel_local","(port, bind_address=\"127.0.0.1\")","<p>Terminates an active local forwarded port.\n\n<pre>ssh.forward.cancel_local(1234)\nssh.forward.cancel_local(1234, ...</pre>\n"],["cancel_local_socket","Net::SSH::Service::Forward","Net/SSH/Service/Forward.html#method-i-cancel_local_socket","(local_socket_path)","<p>Terminates an active local forwarded socket.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">ssh</span>.<span class=\"ruby-identifier\">forward</span>.<span class=\"ruby-identifier\">cancel_local_socket</span>(<span class=\"ruby-string\">&#39;/tmp/foo.sock&#39;</span>)\n</pre>\n"],["cancel_remote","Net::SSH::Service::Forward","Net/SSH/Service/Forward.html#method-i-cancel_remote","(port, host=\"127.0.0.1\")","<p>Requests that a remote forwarded port be cancelled. The remote forwarded\nport on the remote host, bound …\n"],["cleanup","Net::SSH::Transport::PacketStream","Net/SSH/Transport/PacketStream.html#method-i-cleanup","()","<p>Performs any pending cleanup necessary on the IO and its associated state\nobjects. (See State#cleanup …\n"],["cleanup","Net::SSH::Transport::State","Net/SSH/Transport/State.html#method-i-cleanup","()","<p>Closes any the compressor and/or decompressor objects that have been\ninstantiated.\n"],["cleanup_channel","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-cleanup_channel","(channel)",""],["clear!","Net::SSH::Authentication::KeyManager","Net/SSH/Authentication/KeyManager.html#method-i-clear-21","()","<p>Clear all knowledge of any loaded user keys. This also clears the list of\ndefault identity files that …\n"],["clear!","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-clear-21","()","<p>Resets the buffer, making it empty. Also, resets the read position to 0.\n"],["client_name","Net::SSH::Transport::PacketStream","Net/SSH/Transport/PacketStream.html#method-i-client_name","()","<p>The name of the client (local) end of the socket, as reported by the\nsocket.\n"],["close","Net::SSH::Authentication::Agent","Net/SSH/Authentication/Agent.html#method-i-close","()","<p>Closes this socket. This agent reference is no longer able to query the\nagent.\n"],["close","Net::SSH::Authentication::Pageant::Socket","Net/SSH/Authentication/Pageant/Socket.html#method-i-close","()",""],["close","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-close","()","<p>Requests that the channel be closed. It only marks the channel to be closed\nthe CHANNEL_CLOSE message …\n"],["close","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-close","()","<p>Closes the session gracefully, blocking until all channels have\nsuccessfully closed, and then closes …\n"],["close","Net::SSH::Transport::Session","Net/SSH/Transport/Session.html#method-i-close","()","<p>Cleans up (see PacketStream#cleanup) and closes the underlying socket.\n"],["close_on_error","Net::SSH::Proxy::Command","Net/SSH/Proxy/Command.html#method-i-close_on_error","(io)",""],["closed?","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-closed-3F","()","<p>Returns true if the underlying transport has been closed. Note that this\ncan be a little misleading, …\n"],["closed?","Net::SSH::Transport::Session","Net/SSH/Transport/Session.html#method-i-closed-3F","()","<p>Returns true if the underlying socket has been closed.\n"],["closing?","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-closing-3F","()","<p>True if close() has been called; NOTE: if the channel has data waiting to\nbe sent then the channel will …\n"],["compress","Net::SSH::Transport::State","Net/SSH/Transport/State.html#method-i-compress","(data)","<p>Compresses the data. If no compression is in effect, this will just return\nthe data unmodified, otherwise …\n"],["compression?","Net::SSH::Transport::State","Net/SSH/Transport/State.html#method-i-compression-3F","()","<p>Returns true if data compression/decompression is enabled. This will return\ntrue if :standard compression …\n"],["compressor","Net::SSH::Transport::State","Net/SSH/Transport/State.html#method-i-compressor","()","<p>The compressor object to use when compressing data. This takes into account\nthe desired compression level. …\n"],["configuration_for","Net::SSH","Net/SSH.html#method-c-configuration_for","(host, use_ssh_config)","<p>Returns a hash of the configuration options for the given host, as read\nfrom the SSH configuration file(s). …\n"],["configure_client","Net::SSH::Transport::Session","Net/SSH/Transport/Session.html#method-i-configure_client","(options={})","<p>Configure&#39;s the packet stream&#39;s client state with the given set of\noptions. This is typically …\n"],["configure_server","Net::SSH::Transport::Session","Net/SSH/Transport/Session.html#method-i-configure_server","(options={})","<p>Configure&#39;s the packet stream&#39;s server state with the given set of\noptions. This is typically …\n"],["connect","Net::SSH::Authentication::Agent","Net/SSH/Authentication/Agent.html#method-c-connect","(logger=nil, agent_socket_factory = nil, identity_agent = nil)","<p>Instantiates a new agent object, connects to a running SSH agent,\nnegotiates the agent protocol version, …\n"],["connect!","Net::SSH::Authentication::Agent","Net/SSH/Authentication/Agent.html#method-i-connect-21","(agent_socket_factory = nil, identity_agent = nil)","<p>Connect to the agent process using the socket factory and socket name given\nby the attribute writers. …\n"],["connection","Net::SSH::Test","Net/SSH/Test.html#method-i-connection","(options={})","<p>Returns the connection session (Net::SSH::Connection::Session) for use in\nthese tests. It is a fully …\n"],["consume!","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-consume-21","(n=position)","<p>Consumes n bytes from the buffer, where n is the current position unless\notherwise specified. This is …\n"],["curve_name","Net::SSH::Transport::Kex::Abstract5656","Net/SSH/Transport/Kex/Abstract5656.html#method-i-curve_name","()",""],["curve_name","Net::SSH::Transport::Kex::EcdhSHA2NistP256","Net/SSH/Transport/Kex/EcdhSHA2NistP256.html#method-i-curve_name","()",""],["curve_name","Net::SSH::Transport::Kex::EcdhSHA2NistP384","Net/SSH/Transport/Kex/EcdhSHA2NistP384.html#method-i-curve_name","()",""],["curve_name","Net::SSH::Transport::Kex::EcdhSHA2NistP521","Net/SSH/Transport/Kex/EcdhSHA2NistP521.html#method-i-curve_name","()",""],["debug","Net::SSH::Loggable","Net/SSH/Loggable.html#method-i-debug","()","<p>Displays the result of yielding if the log level is Logger::DEBUG or\ngreater.\n"],["decompress","Net::SSH::Transport::State","Net/SSH/Transport/State.html#method-i-decompress","(data)","<p>Deompresses the data. If no compression is in effect, this will just return\nthe data unmodified, otherwise …\n"],["decompressor","Net::SSH::Transport::State","Net/SSH/Transport/State.html#method-i-decompressor","()","<p>The decompressor object to use when decompressing data.\n"],["decrypt","Net::SSH::Transport::CTR","Net/SSH/Transport/CTR.html#method-i-decrypt","()",""],["decrypt","Net::SSH::Transport::IdentityCipher","Net/SSH/Transport/IdentityCipher.html#method-c-decrypt","()","<p>Does nothing. Returns self.\n"],["default","Net::SSH::Prompt","Net/SSH/Prompt.html#method-c-default","(options = {})","<p>factory\n"],["default_auth_methods","Net::SSH::Config","Net/SSH/Config.html#method-c-default_auth_methods","()",""],["default_files","Net::SSH::Config","Net/SSH/Config.html#method-c-default_files","()","<p>Returns an array of locations of OpenSSH configuration files to parse by\ndefault.\n"],["dependenciesRequiredForED25519","Net::SSH::Authentication::ED25519Loader","Net/SSH/Authentication/ED25519Loader.html#method-c-dependenciesRequiredForED25519","()",""],["dependenciesRequiredForX25519","Net::SSH::Transport::Kex::Curve25519Sha256Loader","Net/SSH/Transport/Kex/Curve25519Sha256Loader.html#method-c-dependenciesRequiredForX25519","()",""],["digest","Net::SSH::Transport::HMAC::Abstract","Net/SSH/Transport/HMAC/Abstract.html#method-i-digest","(data)","<p>Compute the HMAC digest for the given data string.\n"],["digest","Net::SSH::Transport::HMAC::None","Net/SSH/Transport/HMAC/None.html#method-i-digest","(data)",""],["digest_class","Net::SSH::Transport::HMAC::Abstract","Net/SSH/Transport/HMAC/Abstract.html#method-i-digest_class","()",""],["digest_class","Net::SSH::Transport::HMAC::Abstract","Net/SSH/Transport/HMAC/Abstract.html#method-c-digest_class","(*v)",""],["digester","Net::SSH::Transport::Kex::Abstract","Net/SSH/Transport/Kex/Abstract.html#method-i-digester","()",""],["digester","Net::SSH::Transport::Kex::Curve25519Sha256","Net/SSH/Transport/Kex/Curve25519Sha256.html#method-i-digester","()",""],["digester","Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1","Net/SSH/Transport/Kex/DiffieHellmanGroup1SHA1.html#method-i-digester","()",""],["digester","Net::SSH::Transport::Kex::DiffieHellmanGroupExchangeSHA256","Net/SSH/Transport/Kex/DiffieHellmanGroupExchangeSHA256.html#method-i-digester","()",""],["digester","Net::SSH::Transport::Kex::EcdhSHA2NistP256","Net/SSH/Transport/Kex/EcdhSHA2NistP256.html#method-i-digester","()",""],["digester","Net::SSH::Transport::Kex::EcdhSHA2NistP384","Net/SSH/Transport/Kex/EcdhSHA2NistP384.html#method-i-digester","()",""],["digester","Net::SSH::Transport::Kex::EcdhSHA2NistP521","Net/SSH/Transport/Kex/EcdhSHA2NistP521.html#method-i-digester","()",""],["do_close","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-do_close","()","<p>Invokes the #on_close callback when the server closes a channel. The\nchannel is the only argument.\n"],["do_eof","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-do_eof","()","<p>Invokes the #on_eof callback when the server indicates that no further data\nis forthcoming. The callback …\n"],["do_extended_data","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-do_extended_data","(type, data)","<p>Invokes the #on_extended_data callback when the server sends extended data\nto the channel. This will …\n"],["do_failure","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-do_failure","()","<p>Invokes the next pending request callback with <code>false</code> as the\nsecond argument.\n"],["do_open_failed","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-do_open_failed","(reason_code, description)","<p>Invoked when the server failed to open the channel. If an #on_open_failed\ncallback was specified, it …\n"],["do_success","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-do_success","()","<p>Invokes the next pending request callback with <code>true</code> as the\nsecond argument.\n"],["each","Net::SSH::HostKeys","Net/SSH/HostKeys.html#method-i-each","(&block)",""],["each_identity","Net::SSH::Authentication::KeyManager","Net/SSH/Authentication/KeyManager.html#method-i-each_identity","()","<p>Iterates over all available identities (public keys) known to this manager.\nAs it finds one, it will …\n"],["empty?","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-empty-3F","()","<p>Returns <code>true</code> if the buffer contains no data (e.g., it is of\nzero length).\n"],["empty?","Net::SSH::HostKeys","Net/SSH/HostKeys.html#method-i-empty-3F","()",""],["enabled?","Net::SSH::Connection::Keepalive","Net/SSH/Connection/Keepalive.html#method-i-enabled-3F","()",""],["encrypt","Net::SSH::Transport::CTR","Net/SSH/Transport/CTR.html#method-i-encrypt","()",""],["encrypt","Net::SSH::Transport::IdentityCipher","Net/SSH/Transport/IdentityCipher.html#method-c-encrypt","()","<p>Does nothing. Returns self.\n"],["encrypted_key?","Net::SSH::Authentication::ED25519::OpenSSHPrivateKeyLoader::DecryptError","Net/SSH/Authentication/ED25519/OpenSSHPrivateKeyLoader/DecryptError.html#method-i-encrypted_key-3F","()",""],["encrypted_key?","Net::SSH::KeyFactory::KeyType","Net/SSH/KeyFactory/KeyType.html#method-c-encrypted_key-3F","(data, error)",""],["encrypted_key?","Net::SSH::KeyFactory::OpenSSHPrivateKeyType","Net/SSH/KeyFactory/OpenSSHPrivateKeyType.html#method-c-encrypted_key-3F","(key_data, decode_error)",""],["encrypted_key?","Net::SSH::KeyFactory::OpenSSLKeyTypeBase","Net/SSH/KeyFactory/OpenSSLKeyTypeBase.html#method-c-encrypted_key-3F","(key_data, error)",""],["enqueue","Net::SSH::BufferedIo","Net/SSH/BufferedIo.html#method-i-enqueue","(data)","<p>Enqueues data in the output buffer, to be written when #send_pending is\ncalled. Note that the data is …\n"],["enqueue_message","Net::SSH::Transport::Session","Net/SSH/Transport/Session.html#method-i-enqueue_message","(message)","<p>Enqueues the given message, such that it will be sent at the earliest\nopportunity. This does not block, …\n"],["enqueue_packet","Net::SSH::Transport::PacketStream","Net/SSH/Transport/PacketStream.html#method-i-enqueue_packet","(payload)","<p>Enqueues a packet to be sent, but does not immediately send the packet. The\ngiven payload is pre-processed …\n"],["env","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-env","(variable_name, variable_value, &block)","<p>Syntactic sugar for setting an environment variable in the remote\nprocess&#39; environment. Note that …\n"],["eof!","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-eof-21","()","<p>Tells the remote end of the channel that no more data is forthcoming from\nthis end of the channel. The …\n"],["eof?","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-eof-3F","()","<p>Returns true if the pointer is at the end of the buffer. Subsequent reads\nwill return nil, in this case. …\n"],["eof?","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-eof-3F","()","<p>Returns true if the local end of the channel has declared that no more data\nis forthcoming (see #eof! …\n"],["error","Net::SSH::Loggable","Net/SSH/Loggable.html#method-i-error","()","<p>Displays the result of yielding if the log level is Logger:ERROR or\ngreater.\n"],["error_classes","Net::SSH::KeyFactory::KeyType","Net/SSH/KeyFactory/KeyType.html#method-c-error_classes","()",""],["error_classes","Net::SSH::KeyFactory::OpenSSHPrivateKeyType","Net/SSH/KeyFactory/OpenSSHPrivateKeyType.html#method-c-error_classes","()",""],["error_classes","Net::SSH::KeyFactory::OpenSSLDSAKeyType","Net/SSH/KeyFactory/OpenSSLDSAKeyType.html#method-c-error_classes","()",""],["error_classes","Net::SSH::KeyFactory::OpenSSLECKeyType","Net/SSH/KeyFactory/OpenSSLECKeyType.html#method-c-error_classes","()",""],["error_classes","Net::SSH::KeyFactory::OpenSSLPKeyType","Net/SSH/KeyFactory/OpenSSLPKeyType.html#method-c-error_classes","()",""],["error_classes","Net::SSH::KeyFactory::OpenSSLRSAKeyType","Net/SSH/KeyFactory/OpenSSLRSAKeyType.html#method-c-error_classes","()",""],["establish_connection","Net::SSH::Proxy::HTTP","Net/SSH/Proxy/HTTP.html#method-i-establish_connection","(connect_timeout)",""],["establish_connection","Net::SSH::Proxy::HTTPS","Net/SSH/Proxy/HTTPS.html#method-i-establish_connection","(connect_timeout)",""],["etm","Net::SSH::Transport::HMAC::Abstract","Net/SSH/Transport/HMAC/Abstract.html#method-i-etm","()",""],["etm","Net::SSH::Transport::HMAC::Abstract","Net/SSH/Transport/HMAC/Abstract.html#method-c-etm","(*v)",""],["ev_do_calculate_rw_wait","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-ev_do_calculate_rw_wait","(wait)","<p>Returns the file descriptors the event loop should wait for read/write\nevents, we also return the max …\n"],["ev_do_handle_events","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-ev_do_handle_events","(readers, writers)","<p>It loops over the given arrays of reader IO&#39;s and writer IO&#39;s,\nprocessing them as needed, and …\n"],["ev_do_postprocess","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-ev_do_postprocess","(was_events)","<p>calls Net::SSH::Transport::Session#rekey_as_needed to allow the transport\nlayer to rekey\n"],["ev_preprocess","Net::SSH::Connection::EventLoop","Net/SSH/Connection/EventLoop.html#method-i-ev_preprocess","(&block)","<p>Call preprocess on each session. If block given and that block retuns false\nthen we exit the processing …\n"],["ev_preprocess","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-ev_preprocess","(&block)","<p>Called by event loop to process available data before going to event\nmultiplexing\n"],["ev_preprocess","Net::SSH::Connection::SingleSessionEventLoop","Net/SSH/Connection/SingleSessionEventLoop.html#method-i-ev_preprocess","(&block)","<p>Compatibility for original single session event loops: we call block with\nsession as argument\n"],["ev_select_and_postprocess","Net::SSH::Connection::EventLoop","Net/SSH/Connection/EventLoop.html#method-i-ev_select_and_postprocess","(wait)",""],["ev_select_and_postprocess","Net::SSH::Connection::SingleSessionEventLoop","Net/SSH/Connection/SingleSessionEventLoop.html#method-i-ev_select_and_postprocess","(wait)",""],["exchange_keys","Net::SSH::Test::Kex","Net/SSH/Test/Kex.html#method-i-exchange_keys","()","<p>Exchange keys with the server. This returns a hash of constant values, and\ndoes not actually exchange …\n"],["exchange_keys","Net::SSH::Transport::Kex::Abstract","Net/SSH/Transport/Kex/Abstract.html#method-i-exchange_keys","()","<p>Perform the key-exchange for the given session, with the given data. This\nmethod will return a hash consisting …\n"],["exec","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-exec","(command, &block)","<p>Syntactic sugar for executing a command. Sends a channel request asking\nthat the given command be invoked. …\n"],["exec","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-exec","(command, status: nil, &block)","<p>A convenience method for executing a command and interacting with it. If no\nblock is given, all output …\n"],["exec!","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-exec-21","(command, status: nil, &block)","<p>Same as #exec, except this will block until the command finishes. Also, if\nno block is given, this will …\n"],["expand_key","Net::SSH::Transport::KeyExpander","Net/SSH/Transport/KeyExpander.html#method-c-expand_key","(bytes, start, options={})","<p>Generate a key value in accordance with the SSH2 specification. (RFC4253\n7.2. “Output from Key Exchange”) …\n"],["expandable_default_files","Net::SSH::Config","Net/SSH/Config.html#method-c-expandable_default_files","()","<p>Filters default_files down to the files that are expandable.\n"],["expect_message","Net::SSH::Authentication::Session","Net/SSH/Authentication/Session.html#method-i-expect_message","(type)","<p>Blocks until a packet is received, and returns it if it is of the given\ntype. If it is not, an exception …\n"],["extended","Net::SSH::Transport::CTR","Net/SSH/Transport/CTR.html#method-c-extended","(orig)",""],["extended","Net::SSH::Transport::PacketStream","Net/SSH/Transport/PacketStream.html#method-c-extended","(object)",""],["extension_enabled?","Net::SSH::Test::Extensions::IO","Net/SSH/Test/Extensions/IO.html#method-c-extension_enabled-3F","()",""],["fatal","Net::SSH::Loggable","Net/SSH/Loggable.html#method-i-fatal","()","<p>Displays the result of yielding if the log level is Logger::FATAL or\ngreater.\n"],["fill","Net::SSH::BufferedIo","Net/SSH/BufferedIo.html#method-i-fill","(n=8192)","<p>Tries to read up to <code>n</code> bytes of data from the remote end, and\nappends the data to the input buffer. It …\n"],["fill","Net::SSH::ForwardedBufferedIo","Net/SSH/ForwardedBufferedIo.html#method-i-fill","(n=8192)",""],["final","Net::SSH::Transport::CTR","Net/SSH/Transport/CTR.html#method-i-final","()",""],["final","Net::SSH::Transport::IdentityCipher","Net/SSH/Transport/IdentityCipher.html#method-c-final","()","<p>Returns the empty string.\n"],["final_cipher","Net::SSH::Transport::State","Net/SSH/Transport/State.html#method-i-final_cipher","()",""],["fingerprint","Net::SSH::Authentication::Certificate","Net/SSH/Authentication/Certificate.html#method-i-fingerprint","()",""],["fingerprint","Net::SSH::HostKeyError","Net/SSH/HostKeyError.html#method-i-fingerprint","()","<p>Returns the fingerprint of the key for the host, which either was not found\nor did not match.\n"],["finish","Net::SSH::Authentication::KeyManager","Net/SSH/Authentication/KeyManager.html#method-i-finish","()","<p>This is used as a hint to the KeyManager indicating that the agent\nconnection is no longer needed. Any …\n"],["for","Net::SSH::Config","Net/SSH/Config.html#method-c-for","(host, files=expandable_default_files)","<p>Loads the configuration data for the given <code>host</code> from all of\nthe given <code>files</code> (defaulting to the list of …\n"],["forward","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-forward","()","<p>Returns a reference to the Net::SSH::Service::Forward service, which can be\nused for forwarding ports …\n"],["from","Net::SSH::Buffer","Net/SSH/Buffer.html#method-c-from","(*args)","<p>This is a convenience method for creating and populating a new buffer from\na single command. The arguments …\n"],["get","Net::SSH::KeyFactory","Net/SSH/KeyFactory.html#method-c-get","(name)","<p>Fetch an OpenSSL key instance by its SSH name. It will be a new, empty key\nof the given type.\n"],["get","Net::SSH::Transport::CipherFactory","Net/SSH/Transport/CipherFactory.html#method-c-get","(name, options={})","<p>Retrieves a new instance of the named algorithm. The new instance will be\ninitialized using an iv and …\n"],["get","Net::SSH::Transport::HMAC","Net/SSH/Transport/HMAC.html#method-c-get","(name, key=\"\", parameters = {})","<p>Retrieves a new hmac instance of the given SSH type (<code>name</code>). If\n<code>key</code> is given, the new instance will be …\n"],["get_lengths","Net::SSH::Transport::CipherFactory","Net/SSH/Transport/CipherFactory.html#method-c-get_lengths","(name, options = {})","<p>Returns a two-element array containing the [ key-length, block-size ] for\nthe named cipher algorithm. …\n"],["get_ptr","Net::SSH::Authentication::Pageant::Win","Net/SSH/Authentication/Pageant/Win.html#method-c-get_ptr","(data)",""],["getbyte","String","String.html#method-i-getbyte","(index)",""],["getpeername","Net::SSH::Test::Socket","Net/SSH/Test/Socket.html#method-i-getpeername","()","<p>Returns a sockaddr struct for the port and host that were used when the\nsocket was instantiated.\n"],["gets","Net::SSH::Test::Script","Net/SSH/Test/Script.html#method-i-gets","(type, *args)","<p>A convenience method for adding an arbitrary remote packet to the events\nlist.\n"],["gets_channel_close","Net::SSH::Test::Script","Net/SSH/Test/Script.html#method-i-gets_channel_close","(channel)","<p>Scripts the reception of a channel close packet from the remote host by the\ngiven Net::SSH::Test::Channel …\n"],["gets_channel_data","Net::SSH::Test::Script","Net/SSH/Test/Script.html#method-i-gets_channel_data","(channel, data)","<p>Scripts the reception of a channel data packet from the remote host by the\ngiven Net::SSH::Test::Channel …\n"],["gets_channel_eof","Net::SSH::Test::Script","Net/SSH/Test/Script.html#method-i-gets_channel_eof","(channel)","<p>Scripts the reception of a channel EOF packet from the remote host by the\ngiven Net::SSH::Test::Channel …\n"],["gets_channel_extended_data","Net::SSH::Test::Script","Net/SSH/Test/Script.html#method-i-gets_channel_extended_data","(channel, data)","<p>Scripts the reception of a channel extended data packet from the remote\nhost by the given Net::SSH::Test::Channel …\n"],["gets_channel_request","Net::SSH::Test::Script","Net/SSH/Test/Script.html#method-i-gets_channel_request","(channel, request, reply, data)","<p>Scripts the reception of a channel request packet from the remote host by\nthe given Net::SSH::Test::Channel …\n"],["gets_close","Net::SSH::Test::Channel","Net/SSH/Test/Channel.html#method-i-gets_close","()","<p>Scripts the reception of a “channel close” packet from the remote end.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">channel</span>.<span class=\"ruby-identifier\">gets_close</span>\n</pre>\n"],["gets_data","Net::SSH::Test::Channel","Net/SSH/Test/Channel.html#method-i-gets_data","(data)","<p>Scripts the reception of a channel data packet from the remote end.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">channel</span>.<span class=\"ruby-identifier\">gets_data</span> <span class=\"ruby-string\">&quot;bar&quot;</span>\n</pre>\n"],["gets_eof","Net::SSH::Test::Channel","Net/SSH/Test/Channel.html#method-i-gets_eof","()","<p>Scripts the reception of an EOF packet from the remote end.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">channel</span>.<span class=\"ruby-identifier\">gets_eof</span>\n</pre>\n"],["gets_exit_status","Net::SSH::Test::Channel","Net/SSH/Test/Channel.html#method-i-gets_exit_status","(status=0)","<p>Scripts the reception of an “exit-status” channel request packet.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">channel</span>.<span class=\"ruby-identifier\">gets_exit_status</span>(<span class=\"ruby-value\">127</span>)\n</pre>\n"],["gets_extended_data","Net::SSH::Test::Channel","Net/SSH/Test/Channel.html#method-i-gets_extended_data","(data)","<p>Scripts the reception of a channel extended data packet from the remote\nend.\n\n<pre>channel.gets_extended_data ...</pre>\n"],["hint","Net::SSH::Transport::Session","Net/SSH/Transport/Session.html#method-i-hint","(which, value=true)","<p>Sets a new hint for the packet stream, which the packet stream may use to\nchange its behavior. (See  …\n"],["host","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-host","()","<p>Returns the name of the host that was given to the transport layer to\nconnect to.\n"],["host","Net::SSH::HostKeyError","Net/SSH/HostKeyError.html#method-i-host","()","<p>Returns the host name for the remote host, as reported by the socket.\n"],["host_as_string","Net::SSH::Transport::Session","Net/SSH/Transport/Session.html#method-i-host_as_string","()","<p>Returns the host (and possibly IP address) in a format compatible with SSH\nknown-host files.\n"],["host_key_format","Net::SSH::Transport::Algorithms","Net/SSH/Transport/Algorithms.html#method-i-host_key_format","()",""],["host_keys","Net::SSH::Transport::Session","Net/SSH/Transport/Session.html#method-i-host_keys","()",""],["hostfiles","Net::SSH::KnownHosts","Net/SSH/KnownHosts.html#method-c-hostfiles","(options, which=:all)","<p>Looks in the given <code>options</code> hash for the :user_known_hosts_file\nand :global_known_hosts_file keys, and …\n"],["identities","Net::SSH::Authentication::Agent","Net/SSH/Authentication/Agent.html#method-i-identities","()","<p>Return an array of all identities (public keys) known to the agent. Each\nkey returned is augmented with …\n"],["idle!","Net::SSH::Test::Extensions::PacketStream","Net/SSH/Test/Extensions/PacketStream.html#method-i-idle-21","()","<p>Called when another packet should be inspected from the current script. If\nthe next packet is a remote …\n"],["if_needs_rekey?","Net::SSH::Transport::PacketStream","Net/SSH/Transport/PacketStream.html#method-i-if_needs_rekey-3F","()","<p>If the IO object requires a rekey operation (as indicated by either its\nclient or server state objects, …\n"],["increment","Net::SSH::Transport::State","Net/SSH/Transport/State.html#method-i-increment","(packet_length)","<p>Increments the counters. The sequence number is incremented (and remapped\nso it always fits in a 32-bit …\n"],["increment_counter!","Net::SSH::Transport::CTR","Net/SSH/Transport/CTR.html#method-i-increment_counter-21","()",""],["info","Net::SSH::Loggable","Net/SSH/Loggable.html#method-i-info","()","<p>Displays the result of yielding if the log level is Logger::INFO or\ngreater.\n"],["initialize_ssh","Net::SSH::Transport::PacketStream","Net/SSH/Transport/PacketStream.html#method-i-initialize_ssh","()","<p>Called when this module is used to extend an object. It initializes the\nstates and generally prepares …\n"],["initialized?","Net::SSH::Transport::Algorithms","Net/SSH/Transport/Algorithms.html#method-i-initialized-3F","()","<p>Returns true if the algorithms have been negotiated at all.\n"],["inject_remote_delay!","Net::SSH::Test::Channel","Net/SSH/Test/Channel.html#method-i-inject_remote_delay-21","()","<p>Because adjacent calls to #gets_data will sometimes cause the data packets\nto be concatenated (causing …\n"],["instantiate!","Net::SSH::Test::Packet","Net/SSH/Test/Packet.html#method-i-instantiate-21","()","<p>Instantiates the packets data elements. When the packet was first defined,\nsome elements may not have …\n"],["interactive?","Net::SSH::Authentication::Methods::KeyboardInteractive","Net/SSH/Authentication/Methods/KeyboardInteractive.html#method-i-interactive-3F","()",""],["interval","Net::SSH::Connection::Keepalive","Net/SSH/Connection/Keepalive.html#method-i-interval","()",""],["ip","Net::SSH::HostKeyError","Net/SSH/HostKeyError.html#method-i-ip","()","<p>Returns the IP address of the remote host, as reported by the socket.\n"],["iv","Net::SSH::Transport::CTR","Net/SSH/Transport/CTR.html#method-i-iv","()",""],["iv=","Net::SSH::Transport::CTR","Net/SSH/Transport/CTR.html#method-i-iv-3D","(iv_s)",""],["iv=","Net::SSH::Transport::IdentityCipher","Net/SSH/Transport/IdentityCipher.html#method-c-iv-3D","(v)","<p>Does nothing. Returns nil.\n"],["iv=","Net::SSH::Transport::OpenSSLAESCTR","Net/SSH/Transport/OpenSSLAESCTR.html#method-i-iv-3D","(iv_s)",""],["iv_len","Net::SSH::Transport::CTR","Net/SSH/Transport/CTR.html#method-i-iv_len","()",""],["iv_len","Net::SSH::Transport::IdentityCipher","Net/SSH/Transport/IdentityCipher.html#method-c-iv_len","()","<p>Returns an arbitrary integer.\n"],["keepalive_maxcount","Net::SSH::Connection::Keepalive","Net/SSH/Connection/Keepalive.html#method-i-keepalive_maxcount","()",""],["key","Net::SSH::HostKeyError","Net/SSH/HostKeyError.html#method-i-key","()","<p>Returns the key itself, as reported by the remote host.\n"],["key=","Net::SSH::Transport::HMAC::Abstract","Net/SSH/Transport/HMAC/Abstract.html#method-i-key-3D","(value)","<p>Sets the key to the given value, truncating it so that it is the correct\nlength.\n"],["key_length","Net::SSH::Transport::HMAC","Net/SSH/Transport/HMAC.html#method-c-key_length","(name)","<p>Retrieves the key length for the hmac of the given SSH type\n(<code>name</code>).\n"],["key_length","Net::SSH::Transport::HMAC::Abstract","Net/SSH/Transport/HMAC/Abstract.html#method-i-key_length","()",""],["key_length","Net::SSH::Transport::HMAC::Abstract","Net/SSH/Transport/HMAC/Abstract.html#method-c-key_length","(*v)",""],["keys_for","Net::SSH::KnownHosts","Net/SSH/KnownHosts.html#method-i-keys_for","(host, options = {})","<p>Returns an array of all keys that are known to be associatd with the given\nhost. The <code>host</code> parameter is …\n"],["known_host_hash?","Net::SSH::KnownHosts","Net/SSH/KnownHosts.html#method-i-known_host_hash-3F","(hostlist, entries)","<p>Indicates whether one of the entries matches an hostname that has been\nstored as a HMAC-SHA1 hash in …\n"],["length","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-length","()","<p>Returns the length of the buffer&#39;s content.\n"],["listen_to","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-listen_to","(io, &callback)","<p>Adds an IO object for the event loop to listen to. If a callback is given,\nit will be invoked when the …\n"],["load","Net::SSH::Config","Net/SSH/Config.html#method-c-load","(path, host, settings={}, base_dir = nil)","<p>Load the OpenSSH configuration settings in the given <code>file</code> for\nthe given <code>host</code>. If <code>settings</code> is given, the …\n"],["load_data_private_key","Net::SSH::KeyFactory","Net/SSH/KeyFactory.html#method-c-load_data_private_key","(data, passphrase=nil, ask_passphrase=true, filename=\"\", prompt=Prompt.default)","<p>Loads a private key. It will correctly determine whether the file describes\nan RSA or DSA key, and will …\n"],["load_data_public_key","Net::SSH::KeyFactory","Net/SSH/KeyFactory.html#method-c-load_data_public_key","(data, filename=\"\")","<p>Loads a public key. It will correctly determine whether the file describes\nan RSA or DSA key, and will …\n"],["load_private_key","Net::SSH::KeyFactory","Net/SSH/KeyFactory.html#method-c-load_private_key","(filename, passphrase=nil, ask_passphrase=true, prompt=Prompt.default)","<p>Loads a private key from a file. It will correctly determine whether the\nfile describes an RSA or DSA …\n"],["load_public_key","Net::SSH::KeyFactory","Net/SSH/KeyFactory.html#method-c-load_public_key","(filename)","<p>Loads a public key from a file. It will correctly determine whether the\nfile describes an RSA or DSA …\n"],["local","Net::SSH::Service::Forward","Net/SSH/Service/Forward.html#method-i-local","(*args)","<p>Starts listening for connections on the local host, and forwards them to\nthe specified remote host/port …\n"],["local?","Net::SSH::Test::LocalPacket","Net/SSH/Test/LocalPacket.html#method-i-local-3F","()","<p>Returns <code>true</code>; this is a local packet.\n"],["local?","Net::SSH::Test::Packet","Net/SSH/Test/Packet.html#method-i-local-3F","()","<p>The default for <code>local?</code> is false. Subclasses should override as\nnecessary.\n"],["local_closed?","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-local_closed-3F","()","<p>True if we have sent CHANNEL_CLOSE to the remote server.\n"],["local_id","Net::SSH::Test::Channel","Net/SSH/Test/Channel.html#method-i-local_id","()","<p>Returns the local (client-assigned) id for this channel, or a Proc object\nthat will return the local-id …\n"],["local_socket","Net::SSH::Service::Forward","Net/SSH/Service/Forward.html#method-i-local_socket","(local_socket_path, remote_socket_path)","<p>Starts listening for connections on the local host, and forwards them to\nthe specified remote socket …\n"],["loop","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-loop","(wait=nil, &block)","<p>The main event loop. Calls #process until #process returns false. If a\nblock is given, it is passed to …\n"],["loop_forever","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-loop_forever","(wait=nil, &block)","<p>preserve a reference to Kernel#loop\n"],["lwarn","Net::SSH::Loggable","Net/SSH/Loggable.html#method-i-lwarn","()","<p>Displays the result of yielding if the log level is Logger::WARN or\ngreater. (Called lwarn to avoid shadowing …\n"],["mac_length","Net::SSH::Transport::HMAC::Abstract","Net/SSH/Transport/HMAC/Abstract.html#method-c-mac_length","(*v)",""],["mac_length","Net::SSH::Transport::HMAC::Abstract","Net/SSH/Transport/HMAC/Abstract.html#method-i-mac_length","()",""],["malloc_ptr","Net::SSH::Authentication::Pageant::Win","Net/SSH/Authentication/Pageant/Win.html#method-c-malloc_ptr","(size)",""],["match","Net::SSH::KnownHosts","Net/SSH/KnownHosts.html#method-i-match","(host, pattern)",""],["max_select_wait_time","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-max_select_wait_time","()","<p>If the #preprocess and #postprocess callbacks for this session need to run\nperiodically, this method …\n"],["method_missing","Net::SSH::Connection::Session::NilChannel","Net/SSH/Connection/Session/NilChannel.html#method-i-method_missing","(sym, *args)",""],["name","Net::SSH::Transport::IdentityCipher","Net/SSH/Transport/IdentityCipher.html#method-c-name","()","<p>The name of this cipher, which is “identity”.\n"],["needs_rekey?","Net::SSH::Transport::State","Net/SSH/Transport/State.html#method-i-needs_rekey-3F","()","<p>Returns true if the number of packets processed exceeds the maximum number\nof packets, or if the number …\n"],["negotiate!","Net::SSH::Authentication::Agent","Net/SSH/Authentication/Agent.html#method-i-negotiate-21","()","<p>Attempts to negotiate the SSH agent protocol version. Raises an error if\nthe version could not be negotiated …\n"],["new","Net::SSH::Authentication::Agent","Net/SSH/Authentication/Agent.html#method-c-new","(logger=nil)","<p>Creates a new Agent object, using the optional logger instance to report\nstatus.\n"],["new","Net::SSH::Authentication::ED25519::OpenSSHPrivateKeyLoader::DecryptError","Net/SSH/Authentication/ED25519/OpenSSHPrivateKeyLoader/DecryptError.html#method-c-new","(message, encrypted_key: false)",""],["new","Net::SSH::Authentication::ED25519::PrivKey","Net/SSH/Authentication/ED25519/PrivKey.html#method-c-new","(buffer)",""],["new","Net::SSH::Authentication::ED25519::PubKey","Net/SSH/Authentication/ED25519/PubKey.html#method-c-new","(data)",""],["new","Net::SSH::Authentication::ED25519::SigningKeyFromFile","Net/SSH/Authentication/ED25519/SigningKeyFromFile.html#method-c-new","(pk,sk)",""],["new","Net::SSH::Authentication::KeyManager","Net/SSH/Authentication/KeyManager.html#method-c-new","(logger, options={})","<p>Create a new KeyManager. By default, the manager will use the ssh-agent if\nit is running and the `:use_agent` …\n"],["new","Net::SSH::Authentication::Methods::Abstract","Net/SSH/Authentication/Methods/Abstract.html#method-c-new","(session, options={})","<p>Instantiates a new authentication method.\n"],["new","Net::SSH::Authentication::Pageant::Socket","Net/SSH/Authentication/Pageant/Socket.html#method-c-new","()","<p>Create a new instance that communicates with the running pageant instance.\nIf no such instance is running, …\n"],["new","Net::SSH::Authentication::Session","Net/SSH/Authentication/Session.html#method-c-new","(transport, options={})","<p>Instantiates a new Authentication::Session object over the given transport\nlayer abstraction.\n"],["new","Net::SSH::Buffer","Net/SSH/Buffer.html#method-c-new","(content=\"\")","<p>Creates a new buffer, initialized to the given content. The position is\ninitialized to the beginning …\n"],["new","Net::SSH::ChannelOpenFailed","Net/SSH/ChannelOpenFailed.html#method-c-new","(code, reason)",""],["new","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-c-new","(connection, type, local_id, max_pkt_size = 0x8000, max_win_size = 0x20000, &on_confirm_open)","<p>Instantiates a new channel on the given connection, of the given type, and\nwith the given id. If a block …\n"],["new","Net::SSH::Connection::EventLoop","Net/SSH/Connection/EventLoop.html#method-c-new","(logger=nil)",""],["new","Net::SSH::Connection::Keepalive","Net/SSH/Connection/Keepalive.html#method-c-new","(session)",""],["new","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-c-new","(transport, options={})","<p>Create a new connection service instance atop the given transport layer.\nInitializes the listeners to …\n"],["new","Net::SSH::Connection::Session::NilChannel","Net/SSH/Connection/Session/NilChannel.html#method-c-new","(session)",""],["new","Net::SSH::Connection::Session::StringWithExitstatus","Net/SSH/Connection/Session/StringWithExitstatus.html#method-c-new","(str, exitstatus)",""],["new","Net::SSH::HostKeys","Net/SSH/HostKeys.html#method-c-new","(host_keys, host, known_hosts, options = {})",""],["new","Net::SSH::KnownHosts","Net/SSH/KnownHosts.html#method-c-new","(source)","<p>Instantiate a new KnownHosts instance that will search the given\nknown-hosts file. The path is expanded …\n"],["new","Net::SSH::Packet","Net/SSH/Packet.html#method-c-new","(payload)","<p>Create a new packet from the given payload. This will automatically parse\nthe packet if it is one that …\n"],["new","Net::SSH::Prompt","Net/SSH/Prompt.html#method-c-new","(options = {})",""],["new","Net::SSH::Prompt::Prompter","Net/SSH/Prompt/Prompter.html#method-c-new","(info)",""],["new","Net::SSH::Proxy::Command","Net/SSH/Proxy/Command.html#method-c-new","(command_line_template)","<p>Create a new socket factory that tunnels via a command executed with the\nuser&#39;s shell, which is composed …\n"],["new","Net::SSH::Proxy::HTTP","Net/SSH/Proxy/HTTP.html#method-c-new","(proxy_host, proxy_port=80, options={})","<p>Create a new socket factory that tunnels via the given host and port. The\n<code>options</code> parameter is a hash …\n"],["new","Net::SSH::Proxy::HTTPS","Net/SSH/Proxy/HTTPS.html#method-c-new","(proxy_host, proxy_port=80, options={})","<p>Create a new socket factory that tunnels via the given host and port. The\n<code>options</code> parameter is a hash …\n"],["new","Net::SSH::Proxy::Jump","Net/SSH/Proxy/Jump.html#method-c-new","(jump_proxies)","<p>Create a new socket factory that tunnels via multiple jump proxes as\n[user@]host.\n"],["new","Net::SSH::Proxy::SOCKS4","Net/SSH/Proxy/SOCKS4.html#method-c-new","(proxy_host, proxy_port=1080, options={})","<p>Create a new proxy connection to the given proxy host and port. Optionally,\na :user key may be given …\n"],["new","Net::SSH::Proxy::SOCKS5","Net/SSH/Proxy/SOCKS5.html#method-c-new","(proxy_host, proxy_port=1080, options={})","<p>Create a new proxy connection to the given proxy host and port. Optionally,\n:user and :password options …\n"],["new","Net::SSH::Service::Forward","Net/SSH/Service/Forward.html#method-c-new","(session)","<p>Instantiates a new Forward service instance atop the given connection\nservice session. This will register …\n"],["new","Net::SSH::Test::Channel","Net/SSH/Test/Channel.html#method-c-new","(script)","<p>Creates a new Test::Channel instance on top of the given\n<code>script</code> (which must be a Net::SSH::Test::Script …\n"],["new","Net::SSH::Test::Kex","Net/SSH/Test/Kex.html#method-c-new","(algorithms, connection, data)","<p>Creates a new instance of the testing key-exchange algorithm with the given\narguments.\n"],["new","Net::SSH::Test::LocalPacket","Net/SSH/Test/LocalPacket.html#method-c-new","(type, *args, &block)","<p>Extend the default Net::SSH::Test::Packet constructor to also accept an\noptional block, which is used …\n"],["new","Net::SSH::Test::Packet","Net/SSH/Test/Packet.html#method-c-new","(type, *args)","<p>Ceate a new packet of the given <code>type</code>, and with\n<code>args</code> being a list of data elements in the order expected …\n"],["new","Net::SSH::Test::Script","Net/SSH/Test/Script.html#method-c-new","()","<p>Create a new, empty script.\n"],["new","Net::SSH::Test::Socket","Net/SSH/Test/Socket.html#method-c-new","()","<p>Create a new test socket. This will also instantiate a new\nNet::SSH::Test::Script and seed it with the …\n"],["new","Net::SSH::Transport::Algorithms","Net/SSH/Transport/Algorithms.html#method-c-new","(session, options={})","<p>Instantiates a new Algorithms object, and prepares the hash of preferred\nalgorithms based on the options …\n"],["new","Net::SSH::Transport::HMAC::Abstract","Net/SSH/Transport/HMAC/Abstract.html#method-c-new","(key=nil)",""],["new","Net::SSH::Transport::Kex::Abstract","Net/SSH/Transport/Kex/Abstract.html#method-c-new","(algorithms, connection, data)","<p>Create a new instance of the Diffie-Hellman Key Exchange algorithm. The\nDiffie-Hellman (DH) key exchange …\n"],["new","Net::SSH::Transport::OpenSSLAESCTR","Net/SSH/Transport/OpenSSLAESCTR.html#method-c-new","(original)",""],["new","Net::SSH::Transport::ServerVersion","Net/SSH/Transport/ServerVersion.html#method-c-new","(socket, logger, timeout = nil)","<p>Instantiates a new ServerVersion and immediately (and synchronously)\nnegotiates the SSH protocol in effect, …\n"],["new","Net::SSH::Transport::Session","Net/SSH/Transport/Session.html#method-c-new","(host, options={})","<p>Instantiates a new transport layer abstraction. This will block until the\ninitial key exchange completes, …\n"],["new","Net::SSH::Transport::Session::CompatibleVerifier","Net/SSH/Transport/Session/CompatibleVerifier.html#method-c-new","(verifier)",""],["new","Net::SSH::Transport::State","Net/SSH/Transport/State.html#method-c-new","(socket, role)","<p>Creates a new state object, belonging to the given socket. Initializes the\nalgorithms to “none”. …\n"],["new","Net::SSH::Version","Net/SSH/Version.html#method-c-new","(major, minor, tiny, pre = nil)","<p>Create a new Version object with the given components.\n"],["next","Net::SSH::Test::Script","Net/SSH/Test/Script.html#method-i-next","(mode=:shift)","<p>By default, removes the next event in the list and returns it. However,\nthis can also be used to non-destructively …\n"],["next_message","Net::SSH::Authentication::Session","Net/SSH/Authentication/Session.html#method-i-next_message","()","<p>Blocks until a packet is received. It silently handles USERAUTH_BANNER\npackets, and will raise an error …\n"],["next_message","Net::SSH::Transport::Session","Net/SSH/Transport/Session.html#method-i-next_message","()","<p>Blocks until a new packet is available to be read, and returns that packet.\nSee #poll_message.\n"],["next_packet","Net::SSH::Transport::PacketStream","Net/SSH/Transport/PacketStream.html#method-i-next_packet","(mode=:nonblock, timeout=nil)","<p>Returns the next full packet. If the mode parameter is :nonblock (the\ndefault), then this will return …\n"],["no_keys?","Net::SSH::Authentication::KeyManager","Net/SSH/Authentication/KeyManager.html#method-i-no_keys-3F","()",""],["on_close","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-on_close","(&block)","<p>Registers a callback to be invoked when the server acknowledges that a\nchannel is closed. This is invoked …\n"],["on_data","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-on_data","(&block)","<p>Registers a callback to be invoked when data packets are received by the\nchannel. The callback is called …\n"],["on_eof","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-on_eof","(&block)","<p>Registers a callback to be invoked when the server indicates that no more\ndata will be sent to the channel …\n"],["on_extended_data","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-on_extended_data","(&block)","<p>Registers a callback to be invoked when extended data packets are received\nby the channel. The callback …\n"],["on_global_request","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-on_global_request","(type, &block)","<p>Registers a handler to be invoked when the server sends a global request of\nthe given type. The callback …\n"],["on_open_channel","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-on_open_channel","(type, &block)","<p>Registers a handler to be invoked when the server wants to open a channel\non the client. The callback …\n"],["on_open_failed","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-on_open_failed","(&block)","<p>Registers a callback to be invoked when the server was unable to open the\nrequested channel. The channel …\n"],["on_process","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-on_process","(&block)","<p>Registers a callback to be invoked for each pass of the event loop for this\nchannel. There are no guarantees …\n"],["on_request","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-on_request","(type, &block)","<p>Registers a callback to be invoked when a channel request of the given type\nis received. The callback …\n"],["open","Net::SSH::Authentication::Pageant::Socket","Net/SSH/Authentication/Pageant/Socket.html#method-c-open","()","<p>The factory method for creating a new Socket instance.\n"],["open","Net::SSH::Proxy::Command","Net/SSH/Proxy/Command.html#method-i-open","(host, port, connection_options = nil)","<p>Return a new socket connected to the given host and port via the proxy that\nwas requested when the socket …\n"],["open","Net::SSH::Proxy::HTTP","Net/SSH/Proxy/HTTP.html#method-i-open","(host, port, connection_options)","<p>Return a new socket connected to the given host and port via the proxy that\nwas requested when the socket …\n"],["open","Net::SSH::Proxy::Jump","Net/SSH/Proxy/Jump.html#method-i-open","(host, port, connection_options = nil)","<p>Return a new socket connected to the given host and port via the jump proxy\nthat was requested when the …\n"],["open","Net::SSH::Proxy::SOCKS4","Net/SSH/Proxy/SOCKS4.html#method-i-open","(host, port, connection_options)","<p>Return a new socket connected to the given host and port via the proxy that\nwas requested when the socket …\n"],["open","Net::SSH::Proxy::SOCKS5","Net/SSH/Proxy/SOCKS5.html#method-i-open","(host, port, connection_options)","<p>Return a new socket connected to the given host and port via the proxy that\nwas requested when the socket …\n"],["open","Net::SSH::Test::Socket","Net/SSH/Test/Socket.html#method-i-open","(host, port, options={})","<p>Allows the socket to also mimic a socket factory, simply returning\n<code>self</code>.\n"],["open_channel","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-open_channel","(type=\"session\", *extra, &on_confirm)","<p>Requests that a new channel be opened. By default, the channel will be of\ntype “session”, but …\n"],["open_ssl_class","Net::SSH::KeyFactory::OpenSSLDSAKeyType","Net/SSH/KeyFactory/OpenSSLDSAKeyType.html#method-c-open_ssl_class","()",""],["open_ssl_class","Net::SSH::KeyFactory::OpenSSLECKeyType","Net/SSH/KeyFactory/OpenSSLECKeyType.html#method-c-open_ssl_class","()",""],["open_ssl_class","Net::SSH::KeyFactory::OpenSSLKeyTypeBase","Net/SSH/KeyFactory/OpenSSLKeyTypeBase.html#method-c-open_ssl_class","()",""],["open_ssl_class","Net::SSH::KeyFactory::OpenSSLPKeyType","Net/SSH/KeyFactory/OpenSSLPKeyType.html#method-c-open_ssl_class","()",""],["open_ssl_class","Net::SSH::KeyFactory::OpenSSLRSAKeyType","Net/SSH/KeyFactory/OpenSSLRSAKeyType.html#method-c-open_ssl_class","()",""],["opens_channel","Net::SSH::Test::Script","Net/SSH/Test/Script.html#method-i-opens_channel","(confirm=true)","<p>Scripts the opening of a channel by adding a local packet sending the\nchannel open request, and if <code>confirm</code> …\n"],["options","Net::SSH::Connection::Keepalive","Net/SSH/Connection/Keepalive.html#method-i-options","()",""],["padding=","Net::SSH::Transport::CTR","Net/SSH/Transport/CTR.html#method-i-padding-3D","(pad)",""],["parse_response","Net::SSH::Proxy::HTTP","Net/SSH/Proxy/HTTP.html#method-i-parse_response","(socket)",""],["peer","Net::SSH::Transport::Session","Net/SSH/Transport/Session.html#method-i-peer","()","<p>Returns a hash of information about the peer (remote) side of the socket,\nincluding :ip, :port, :host, …\n"],["peer_ip","Net::SSH::Transport::PacketStream","Net/SSH/Transport/PacketStream.html#method-i-peer_ip","()","<p>The IP address of the peer (remote) end of the socket, as reported by the\nsocket.\n"],["pending?","Net::SSH::Transport::Algorithms","Net/SSH/Transport/Algorithms.html#method-i-pending-3F","()","<p>Returns <code>true</code> if a key-exchange is pending. This will be true\nfrom the moment either the client or server …\n"],["pending_write?","Net::SSH::BufferedIo","Net/SSH/BufferedIo.html#method-i-pending_write-3F","()","<p>Returns <code>true</code> if there is data waiting in the output buffer,\nand <code>false</code> otherwise.\n"],["poll_message","Net::SSH::Transport::Session","Net/SSH/Transport/Session.html#method-i-poll_message","(mode=:nonblock, consume_queue=true)","<p>Tries to read the next packet from the socket. If mode is :nonblock (the\ndefault), this will not block …\n"],["poll_next_packet","Net::SSH::Transport::PacketStream","Net/SSH/Transport/PacketStream.html#method-i-poll_next_packet","()","<p>Tries to read the next packet. If there is insufficient data to read an\nentire packet, this returns immediately, …\n"],["port","Net::SSH::HostKeyError","Net/SSH/HostKeyError.html#method-i-port","()","<p>Returns the port number for the remote host, as reported by the socket.\n"],["postprocess","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-postprocess","(readers, writers)","<p>This is called internally as part of #process.\n"],["preprocess","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-preprocess","(&block)","<p>This is called internally as part of #process. It dispatches any available\nincoming packets, and then …\n"],["process","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-process","()","<p>If an #on_process handler has been set up, this will cause it to be invoked\n(passing the channel itself …\n"],["process","Net::SSH::Connection::EventLoop","Net/SSH/Connection/EventLoop.html#method-i-process","(wait = nil, &block)","<p>process until timeout if a block is given a session will be removed from\nloop if block returns false …\n"],["process","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-process","(wait=nil, &block)","<p>The core of the event loop. It processes a single iteration of the event\nloop. If a block is given, it …\n"],["process","Net::SSH::Test::LocalPacket","Net/SSH/Test/LocalPacket.html#method-i-process","(packet)","<p>Called by Net::SSH::Test::Extensions::PacketStream#test_enqueue_packet to\nmimic remote processing of …\n"],["process","Net::SSH::Test::RemotePacket","Net/SSH/Test/RemotePacket.html#method-i-process","(packet)","<p>The #process method should only be called on Net::SSH::Test::LocalPacket\npackets; if it is attempted …\n"],["process","Net::SSH::Test::Script","Net/SSH/Test/Script.html#method-i-process","(packet)","<p>Compare the given packet against the next event in the list. If there is no\nnext event, an exception …\n"],["process_only","Net::SSH::Connection::EventLoop","Net/SSH/Connection/EventLoop.html#method-i-process_only","(session, wait = nil)","<p>process the event loop but only for the sepcified session\n"],["public_key","Net::SSH::Authentication::ED25519::PrivKey","Net/SSH/Authentication/ED25519/PrivKey.html#method-i-public_key","()",""],["push","Net::SSH::Transport::Session","Net/SSH/Transport/Session.html#method-i-push","(packet)","<p>Adds the given packet to the packet queue. If the queue is non-empty,\n#poll_message will return packets …\n"],["raiseUnlessLoaded","Net::SSH::Authentication::ED25519Loader","Net/SSH/Authentication/ED25519Loader.html#method-c-raiseUnlessLoaded","(message)",""],["raiseUnlessLoaded","Net::SSH::Transport::Kex::Curve25519Sha256Loader","Net/SSH/Transport/Kex/Curve25519Sha256Loader.html#method-c-raiseUnlessLoaded","(message)",""],["read","Net::SSH::Authentication::ED25519::OpenSSHPrivateKeyLoader","Net/SSH/Authentication/ED25519/OpenSSHPrivateKeyLoader.html#method-c-read","(datafull, password)",""],["read","Net::SSH::Authentication::ED25519::PrivKey","Net/SSH/Authentication/ED25519/PrivKey.html#method-c-read","(data, password)",""],["read","Net::SSH::Authentication::Pageant::Socket","Net/SSH/Authentication/Pageant/Socket.html#method-i-read","(n = nil)","<p>Reads <code>n</code> bytes from the cached result of the last query. If\n<code>n</code> is <code>nil</code>, returns all remaining data from …\n"],["read","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-read","(count=nil)","<p>Reads and returns the next <code>count</code> bytes from the buffer,\nstarting from the read position. If <code>count</code> is …\n"],["read","Net::SSH::KeyFactory::KeyType","Net/SSH/KeyFactory/KeyType.html#method-c-read","(key_data, passphrase)",""],["read","Net::SSH::KeyFactory::OpenSSHPrivateKeyType","Net/SSH/KeyFactory/OpenSSHPrivateKeyType.html#method-c-read","(key_data, passphrase)",""],["read","Net::SSH::KeyFactory::OpenSSLKeyTypeBase","Net/SSH/KeyFactory/OpenSSLKeyTypeBase.html#method-c-read","(key_data, passphrase)",""],["read","Net::SSH::KeyFactory::OpenSSLPKeyType","Net/SSH/KeyFactory/OpenSSLPKeyType.html#method-c-read","(key_data, passphrase)",""],["read!","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-read-21","(count=nil)","<p>Reads (as #read) and returns the given number of bytes from the buffer, and\nthen consumes (as #consume! …\n"],["read_all","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-read_all","(&block)","<p>Calls block(self) until the buffer is empty, and returns all results.\n"],["read_available","Net::SSH::BufferedIo","Net/SSH/BufferedIo.html#method-i-read_available","(length=nil)","<p>Read up to <code>length</code> bytes from the input buffer. If\n<code>length</code> is nil, all available data is read from the …\n"],["read_bignum","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-read_bignum","()","<p>Read a bignum (OpenSSL::BN) from the buffer, in SSH2 format. It is\nessentially just a string, which is …\n"],["read_bool","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-read_bool","()","<p>Read a single byte and convert it into a boolean, using &#39;C&#39; rules\n(i.e., zero is false, non-zero …\n"],["read_buffer","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-read_buffer","()","<p>Reads the next string from the buffer, and returns a new Buffer object that\nwraps it.\n"],["read_byte","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-read_byte","()","<p>Read and return the next byte in the buffer. Returns nil if called at the\nend of the buffer.\n"],["read_certblob","Net::SSH::Authentication::Certificate","Net/SSH/Authentication/Certificate.html#method-c-read_certblob","(buffer, type)","<p>Read a certificate blob associated with a key of the given type.\n"],["read_int64","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-read_int64","()","<p>Return the next 8 bytes as a 64-bit integer (in network byte order).\nReturns nil if there are less than …\n"],["read_key","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-read_key","()","<p>Read a key from the buffer. The key will start with a string describing its\ntype. The remainder of the …\n"],["read_keyblob","Net::SSH::Authentication::ED25519::PubKey","Net/SSH/Authentication/ED25519/PubKey.html#method-c-read_keyblob","(buffer)",""],["read_keyblob","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-read_keyblob","(type)","<p>Read a keyblob of the given type from the buffer, and return it as a key.\nOnly RSA, DSA, and ECDSA keys …\n"],["read_keyblob","OpenSSL::PKey::EC","OpenSSL/PKey/EC.html#method-c-read_keyblob","(curve_name_in_type, buffer)",""],["read_long","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-read_long","()","<p>Return the next four bytes as a long integer (in network byte order).\nReturns nil if there are less than …\n"],["read_private_keyblob","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-read_private_keyblob","(type)",""],["read_string","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-read_string","()","<p>Read and return an SSH2-encoded string. The string starts with a long\ninteger that describes the number …\n"],["read_to","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-read_to","(pattern)","<p>Reads all data up to and including the given pattern, which may be a\nString, Fixnum, or Regexp and is …\n"],["readpartial","Net::SSH::Test::Socket","Net/SSH/Test/Socket.html#method-i-readpartial","(n)",""],["recv","Net::SSH::Test::Socket","Net/SSH/Test/Socket.html#method-i-recv","(n)","<p>Alias to #read, but never returns nil (returns an empty string instead).\n"],["register","Net::SSH::Connection::EventLoop","Net/SSH/Connection/EventLoop.html#method-i-register","(session)",""],["register","Net::SSH::Packet","Net/SSH/Packet.html#method-c-register","(type, *pairs)","<p>Register a new packet type that should be recognized and auto-parsed by\nNet::SSH::Packet. Note that any …\n"],["register_channel_request","Net::SSH::Test::Packet","Net/SSH/Test/Packet.html#method-c-register_channel_request","(request, extra_parts)","<p>Register a custom channel request. extra_parts is an array of types of\nextra parameters\n"],["registered_channel_requests","Net::SSH::Test::Packet","Net/SSH/Test/Packet.html#method-c-registered_channel_requests","(request)",""],["rekey!","Net::SSH::Transport::Algorithms","Net/SSH/Transport/Algorithms.html#method-i-rekey-21","()","<p>Request a rekey operation. This will return immediately, and does not\nactually perform the rekey operation. …\n"],["rekey!","Net::SSH::Transport::Session","Net/SSH/Transport/Session.html#method-i-rekey-21","()","<p>Requests a rekey operation, and blocks until the operation completes. If a\nrekey is already pending, …\n"],["rekey_as_needed","Net::SSH::Transport::Session","Net/SSH/Transport/Session.html#method-i-rekey_as_needed","()","<p>Returns immediately if a rekey is already in process. Otherwise, if a rekey\nis needed (as indicated by …\n"],["remainder_as_buffer","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-remainder_as_buffer","()","<p>Returns all text from the current pointer to the end of the buffer as a new\nNet::SSH::Buffer object. …\n"],["remember_host!","Net::SSH::HostKeyError","Net/SSH/HostKeyError.html#method-i-remember_host-21","()","<p>Tell Net::SSH to record this host and key in the known hosts file, so that\nsubsequent connections will …\n"],["remote","Net::SSH::Service::Forward","Net/SSH/Service/Forward.html#method-i-remote","(port, host, remote_port, remote_host=\"127.0.0.1\")","<p>Requests that all connections on the given remote-port be forwarded via the\nlocal host to the given  …\n"],["remote?","Net::SSH::Test::Packet","Net/SSH/Test/Packet.html#method-i-remote-3F","()","<p>The default for <code>remote?</code> is false. Subclasses should override\nas necessary.\n"],["remote?","Net::SSH::Test::RemotePacket","Net/SSH/Test/RemotePacket.html#method-i-remote-3F","()","<p>Returns <code>true</code>; this is a remote packet.\n"],["remote_closed!","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-remote_closed-21","()",""],["remote_closed?","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-remote_closed-3F","()",""],["remote_id","Net::SSH::Test::Channel","Net/SSH/Test/Channel.html#method-i-remote_id","()","<p>Returns the remote (server-assigned) id for this channel, or a Proc object\nthat will return the remote-id …\n"],["remote_to","Net::SSH::Service::Forward","Net/SSH/Service/Forward.html#method-i-remote_to","(port, host, remote_port, remote_host=\"127.0.0.1\")","<p>an alias, for token backwards compatibility with the 1.x API\n"],["remove_all_identities","Net::SSH::Authentication::Agent","Net/SSH/Authentication/Agent.html#method-i-remove_all_identities","()","<p>Removes all identities from the agent.\n"],["remove_identity","Net::SSH::Authentication::Agent","Net/SSH/Authentication/Agent.html#method-i-remove_identity","(key)","<p>Removes key from the agent.\n"],["request_pty","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-request_pty","(opts={}, &block)","<p>Requests that a pseudo-tty (or “pty”) be made available for this channel.\nThis is useful when …\n"],["reset","Net::SSH::Transport::CTR","Net/SSH/Transport/CTR.html#method-i-reset","()",""],["reset","Net::SSH::Transport::IdentityCipher","Net/SSH/Transport/IdentityCipher.html#method-c-reset","()","<p>Does nothing. Returns self.\n"],["reset","Net::SSH::Transport::OpenSSLAESCTR","Net/SSH/Transport/OpenSSLAESCTR.html#method-i-reset","()",""],["reset!","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-reset-21","()","<p>Resets the pointer to the start of the buffer. Subsequent reads will begin\nat position 0.\n"],["reset!","Net::SSH::Transport::State","Net/SSH/Transport/State.html#method-i-reset-21","()","<p>Resets the counters on the state object, but leaves the sequence_number\nunchanged. It also sets defaults …\n"],["search_for","Net::SSH::KnownHosts","Net/SSH/KnownHosts.html#method-c-search_for","(host, options={})","<p>Searches all known host files (see KnownHosts.hostfiles) for all keys of\nthe given host. Returns an enumerable …\n"],["search_in","Net::SSH::KnownHosts","Net/SSH/KnownHosts.html#method-c-search_in","(files, host, options = {})","<p>Search for all known keys for the given host, in every file given in the\n<code>files</code> array. Returns the list …\n"],["select_for_read?","Net::SSH::Test::Extensions::BufferedIo","Net/SSH/Test/Extensions/BufferedIo.html#method-i-select_for_read-3F","()","<p>Returns <code>true</code> if the position in the stream is less than the\ntotal length of the stream.\n"],["select_for_test","Net::SSH::Test::Extensions::IO::ClassMethods","Net/SSH/Test/Extensions/IO/ClassMethods.html#method-i-select_for_test","(readers=nil, writers=nil, errors=nil, wait=nil)","<p>The testing version of ::IO.select. Assumes that all readers, writers, and\nerrors arrays are either nil, …\n"],["send","Net::SSH::Authentication::Pageant::Socket","Net/SSH/Authentication/Pageant/Socket.html#method-i-send","(data, *args)","<p>Forwards the data to #send_query, ignoring any arguments after the first.\n"],["send","Net::SSH::Proxy::HTTPS::SSLSocketCompatibility","Net/SSH/Proxy/HTTPS/SSLSocketCompatibility.html#method-i-send","(data, _opts)",""],["send_as_needed","Net::SSH::Connection::Keepalive","Net/SSH/Connection/Keepalive.html#method-i-send_as_needed","(was_events)",""],["send_channel_request","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-send_channel_request","(request_name, *data, &callback)","<p>Sends a new channel request with the given name. The extra\n<code>data</code> parameter must either be empty, or consist …\n"],["send_data","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-send_data","(data)","<p>Sends data to the channel&#39;s remote endpoint. This usually has the\neffect of sending the given string …\n"],["send_data_for_test","Net::SSH::Test::Extensions::Channel","Net/SSH/Test/Extensions/Channel.html#method-i-send_data_for_test","(data)","<p>The testing version of Net::SSH::Connection::Channel#send_data. Calls the\noriginal implementation, and …\n"],["send_global_request","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-send_global_request","(type, *extra, &callback)","<p>Send a global request of the given type. The <code>extra</code> parameters\nmust be even in number, and conform to …\n"],["send_message","Net::SSH::Authentication::Methods::Abstract","Net/SSH/Authentication/Methods/Abstract.html#method-i-send_message","(msg)","<p>Sends a message via the underlying transport layer abstraction. This will\nblock until the message is …\n"],["send_message","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-send_message","(message)","<p>Enqueues a message to be sent to the server as soon as the socket is\navailable for writing. Most programs …\n"],["send_message","Net::SSH::Transport::Session","Net/SSH/Transport/Session.html#method-i-send_message","(message)","<p>Sends the given message via the packet stream, blocking until the entire\nmessage has been sent.\n"],["send_packet","Net::SSH::Transport::PacketStream","Net/SSH/Transport/PacketStream.html#method-i-send_packet","(payload)","<p>Enqueues a packet to be sent, and blocks until the entire packet is sent.\n"],["send_pending","Net::SSH::BufferedIo","Net/SSH/BufferedIo.html#method-i-send_pending","()","<p>Sends as much of the pending output as possible. Returns <code>true</code>\nif any data was sent, and <code>false</code> otherwise. …\n"],["send_pending","Net::SSH::ForwardedBufferedIo","Net/SSH/ForwardedBufferedIo.html#method-i-send_pending","()",""],["send_query","Net::SSH::Authentication::Pageant::Socket","Net/SSH/Authentication/Pageant/Socket.html#method-i-send_query","(query)","<p>Packages the given query string and sends it to the pageant process via the\nWindows messaging subsystem. …\n"],["sends","Net::SSH::Test::Script","Net/SSH/Test/Script.html#method-i-sends","(type, *args, &block)","<p>A convenience method for adding an arbitrary local packet to the events\nlist.\n"],["sends_channel_close","Net::SSH::Test::Script","Net/SSH/Test/Script.html#method-i-sends_channel_close","(channel)","<p>Scripts the sending of a channel close packet from the given\nNet::SSH::Test::Channel <code>channel</code>. This will …\n"],["sends_channel_data","Net::SSH::Test::Script","Net/SSH/Test/Script.html#method-i-sends_channel_data","(channel, data)","<p>Scripts the sending of a channel data packet. <code>channel</code> must be\na Net::SSH::Test::Channel object, and  …\n"],["sends_channel_eof","Net::SSH::Test::Script","Net/SSH/Test/Script.html#method-i-sends_channel_eof","(channel)","<p>Scripts the sending of a channel EOF packet from the given\nNet::SSH::Test::Channel <code>channel</code>. This will …\n"],["sends_channel_request","Net::SSH::Test::Script","Net/SSH/Test/Script.html#method-i-sends_channel_request","(channel, request, reply, data, success=true)","<p>Scripts the sending of a new channel request packet to the remote host.\n<code>channel</code> should be an instance …\n"],["sends_channel_request_pty","Net::SSH::Test::Script","Net/SSH/Test/Script.html#method-i-sends_channel_request_pty","(channel)","<p>Scripts the sending of a channel request pty packets from the given\nNet::SSH::Test::Channel <code>channel</code>. …\n"],["sends_close","Net::SSH::Test::Channel","Net/SSH/Test/Channel.html#method-i-sends_close","()","<p>Scripts the sending of a “channel close” packet across the channel.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">channel</span>.<span class=\"ruby-identifier\">sends_close</span>\n</pre>\n"],["sends_data","Net::SSH::Test::Channel","Net/SSH/Test/Channel.html#method-i-sends_data","(data)","<p>Scripts the sending of a data packet across the channel.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">channel</span>.<span class=\"ruby-identifier\">sends_data</span> <span class=\"ruby-string\">&quot;foo&quot;</span>\n</pre>\n"],["sends_eof","Net::SSH::Test::Channel","Net/SSH/Test/Channel.html#method-i-sends_eof","()","<p>Scripts the sending of an EOF packet across the channel.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">channel</span>.<span class=\"ruby-identifier\">sends_eof</span>\n</pre>\n"],["sends_exec","Net::SSH::Test::Channel","Net/SSH/Test/Channel.html#method-i-sends_exec","(command, reply=true, success=true)","<p>Scripts the sending of an “exec” channel request packet to the mock \nserver. If <code>reply</code> is true, …\n"],["sends_request_pty","Net::SSH::Test::Channel","Net/SSH/Test/Channel.html#method-i-sends_request_pty","()","<p>Scripts the sending of a “request pty” request packet across the channel.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">channel</span>.<span class=\"ruby-identifier\">sends_request_pty</span>\n</pre>\n"],["sends_subsystem","Net::SSH::Test::Channel","Net/SSH/Test/Channel.html#method-i-sends_subsystem","(subsystem, reply=true, success=true)","<p>Scripts the sending of a “subsystem” channel request packet to the mock\nserver. See #sends_exec …\n"],["service_request","Net::SSH::Transport::Session","Net/SSH/Transport/Session.html#method-i-service_request","(service)","<p>Returns a new service_request packet for the given service name, ready for\nsending to the server.\n"],["session_id","Net::SSH::Authentication::Methods::Abstract","Net/SSH/Authentication/Methods/Abstract.html#method-i-session_id","()","<p>Returns the session-id, as generated during the first key exchange of an\nSSH connection.\n"],["set","Net::SSH::Transport::State","Net/SSH/Transport/State.html#method-i-set","(values)","<p>A convenience method for quickly setting multiple values in a single\ncommand.\n"],["set_ptr_data","Net::SSH::Authentication::Pageant::Win","Net/SSH/Authentication/Pageant/Win.html#method-c-set_ptr_data","(ptr, data)",""],["setbyte","String","String.html#method-i-setbyte","(index, c)",""],["should_send?","Net::SSH::Connection::Keepalive","Net/SSH/Connection/Keepalive.html#method-i-should_send-3F","()",""],["shutdown!","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-shutdown-21","()","<p>Performs a “hard” shutdown of the connection. In general, this should never\nbe done, but it …\n"],["shutdown!","Net::SSH::Transport::Session","Net/SSH/Transport/Session.html#method-i-shutdown-21","()","<p>Performs a “hard” shutdown of the connection. In general, this should never\nbe done, but it …\n"],["sign","Net::SSH::Authentication::Agent","Net/SSH/Authentication/Agent.html#method-i-sign","(key, data, flags = 0)","<p>Using the agent and the given public key, sign the given data. The\nsignature is returned in SSH2 format. …\n"],["sign","Net::SSH::Authentication::Certificate","Net/SSH/Authentication/Certificate.html#method-i-sign","(key, sign_nonce=nil)",""],["sign","Net::SSH::Authentication::KeyManager","Net/SSH/Authentication/KeyManager.html#method-i-sign","(identity, data)","<p>Sign the given data, using the corresponding private key of the given\nidentity. If the identity was originally …\n"],["sign!","Net::SSH::Authentication::Certificate","Net/SSH/Authentication/Certificate.html#method-i-sign-21","(key, sign_nonce=nil)","<p>Signs the certificate with key.\n"],["signature_valid?","Net::SSH::Authentication::Certificate","Net/SSH/Authentication/Certificate.html#method-i-signature_valid-3F","()","<p>Checks whether the certificate&#39;s signature was signed by signature key.\n"],["socket","Net::SSH::Test","Net/SSH/Test.html#method-i-socket","(options={})","<p>Returns the test socket instance to use for these tests (see\nNet::SSH::Test::Socket).\n"],["ssh_do_sign","Net::SSH::Authentication::Certificate","Net/SSH/Authentication/Certificate.html#method-i-ssh_do_sign","(data)",""],["ssh_do_sign","Net::SSH::Authentication::ED25519::PrivKey","Net/SSH/Authentication/ED25519/PrivKey.html#method-i-ssh_do_sign","(data)",""],["ssh_do_sign","OpenSSL::PKey::DSA","OpenSSL/PKey/DSA.html#method-i-ssh_do_sign","(data)","<p>Signs the given data.\n"],["ssh_do_sign","OpenSSL::PKey::EC","OpenSSL/PKey/EC.html#method-i-ssh_do_sign","(data)","<p>Returns the signature for the given data.\n"],["ssh_do_sign","OpenSSL::PKey::RSA","OpenSSL/PKey/RSA.html#method-i-ssh_do_sign","(data)","<p>Returns the signature for the given data.\n"],["ssh_do_verify","Net::SSH::Authentication::Certificate","Net/SSH/Authentication/Certificate.html#method-i-ssh_do_verify","(sig, data)",""],["ssh_do_verify","Net::SSH::Authentication::ED25519::PubKey","Net/SSH/Authentication/ED25519/PubKey.html#method-i-ssh_do_verify","(sig,data)",""],["ssh_do_verify","OpenSSL::PKey::DSA","OpenSSL/PKey/DSA.html#method-i-ssh_do_verify","(sig, data)","<p>Verifies the given signature matches the given data.\n"],["ssh_do_verify","OpenSSL::PKey::EC","OpenSSL/PKey/EC.html#method-i-ssh_do_verify","(sig, data)","<p>Verifies the given signature matches the given data.\n"],["ssh_do_verify","OpenSSL::PKey::RSA","OpenSSL/PKey/RSA.html#method-i-ssh_do_verify","(sig, data)","<p>Verifies the given signature matches the given data.\n"],["ssh_signature_type","Net::SSH::Authentication::Certificate","Net/SSH/Authentication/Certificate.html#method-i-ssh_signature_type","()",""],["ssh_signature_type","Net::SSH::Authentication::ED25519::PrivKey","Net/SSH/Authentication/ED25519/PrivKey.html#method-i-ssh_signature_type","()",""],["ssh_signature_type","Net::SSH::Authentication::ED25519::PubKey","Net/SSH/Authentication/ED25519/PubKey.html#method-i-ssh_signature_type","()",""],["ssh_signature_type","OpenSSL::PKey::DSA","OpenSSL/PKey/DSA.html#method-i-ssh_signature_type","()",""],["ssh_signature_type","OpenSSL::PKey::EC","OpenSSL/PKey/EC.html#method-i-ssh_signature_type","()",""],["ssh_signature_type","OpenSSL::PKey::RSA","OpenSSL/PKey/RSA.html#method-i-ssh_signature_type","()",""],["ssh_type","Net::SSH::Authentication::Certificate","Net/SSH/Authentication/Certificate.html#method-i-ssh_type","()",""],["ssh_type","Net::SSH::Authentication::ED25519::PrivKey","Net/SSH/Authentication/ED25519/PrivKey.html#method-i-ssh_type","()",""],["ssh_type","Net::SSH::Authentication::ED25519::PubKey","Net/SSH/Authentication/ED25519/PubKey.html#method-i-ssh_type","()",""],["ssh_type","OpenSSL::PKey::DSA","OpenSSL/PKey/DSA.html#method-i-ssh_type","()","<p>Returns “ssh-dss”, which is the description of this key type used by the\nSSH2 protocol.\n"],["ssh_type","OpenSSL::PKey::EC","OpenSSL/PKey/EC.html#method-i-ssh_type","()","<p>Returns the description of this key type used by the SSH2 protocol, like\n“ecdsa-sha2-nistp256” …\n"],["ssh_type","OpenSSL::PKey::EC::Point","OpenSSL/PKey/EC/Point.html#method-i-ssh_type","()","<p>Returns the description of this key type used by the SSH2 protocol, like\n“ecdsa-sha2-nistp256” …\n"],["ssh_type","OpenSSL::PKey::RSA","OpenSSL/PKey/RSA.html#method-i-ssh_type","()","<p>Returns “ssh-rsa”, which is the description of this key type used by the\nSSH2 protocol.\n"],["start","Net::SSH","Net/SSH.html#method-c-start","(host, user=nil, options={}, &block)","<p>The standard means of starting a new SSH connection. When used with a\nblock, the connection will be closed …\n"],["start","Net::SSH::Prompt","Net/SSH/Prompt.html#method-i-start","(info)","<p>start password session. Multiple questions might be asked multiple times on\nthe returned object. Info …\n"],["start","Net::SSH::Transport::Algorithms","Net/SSH/Transport/Algorithms.html#method-i-start","()","<p>Start the algorithm negotation\n"],["stop_listening_to","Net::SSH::Connection::Session","Net/SSH/Connection/Session.html#method-i-stop_listening_to","(io)","<p>Removes the given io object from the listeners collection, so that the\nevent loop will no longer monitor …\n"],["story","Net::SSH::Test","Net/SSH/Test.html#method-i-story","()","<p>If a block is given, yields the script for the test socket (#socket).\nOtherwise, simply returns the socket&#39;s …\n"],["subsystem","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-subsystem","(subsystem, &block)","<p>Syntactic sugar for requesting that a subsystem be started. Subsystems are\na way for other protocols …\n"],["success","Net::SSH::Prompt::Prompter","Net/SSH/Prompt/Prompter.html#method-i-success","()","<p>success method will be called when the password was accepted It&#39;s a\ngood time to save password asked …\n"],["supported?","Net::SSH::Transport::CipherFactory","Net/SSH/Transport/CipherFactory.html#method-c-supported-3F","(name)","<p>Returns true if the underlying OpenSSL library supports the given cipher,\nand false otherwise.\n"],["test_available_for_read?","Net::SSH::Test::Extensions::PacketStream","Net/SSH/Test/Extensions/PacketStream.html#method-i-test_available_for_read-3F","()","<p>The testing version of\nNet::SSH::Transport::PacketStream#available_for_read?. Returns true if\nthere is …\n"],["test_enqueue_packet","Net::SSH::Test::Extensions::PacketStream","Net/SSH/Test/Extensions/PacketStream.html#method-i-test_enqueue_packet","(payload)","<p>The testing version of Net::SSH::Transport::PacketStream#enqueued_packet.\nSimply calls Net::SSH::Test::Script#process …\n"],["test_poll_next_packet","Net::SSH::Test::Extensions::PacketStream","Net/SSH/Test/Extensions/PacketStream.html#method-i-test_poll_next_packet","()","<p>The testing version of Net::SSH::Transport::PacketStream#poll_next_packet.\nReads the next available packet …\n"],["to_blob","Net::SSH::Authentication::Certificate","Net/SSH/Authentication/Certificate.html#method-i-to_blob","()","<p>Serializes the certificate (and key).\n"],["to_blob","Net::SSH::Authentication::ED25519::PrivKey","Net/SSH/Authentication/ED25519/PrivKey.html#method-i-to_blob","()",""],["to_blob","Net::SSH::Authentication::ED25519::PubKey","Net/SSH/Authentication/ED25519/PubKey.html#method-i-to_blob","()",""],["to_blob","OpenSSL::PKey::DSA","OpenSSL/PKey/DSA.html#method-i-to_blob","()","<p>Converts the key to a blob, according to the SSH2 protocol.\n"],["to_blob","OpenSSL::PKey::EC","OpenSSL/PKey/EC.html#method-i-to_blob","()","<p>Converts the key to a blob, according to the SSH2 protocol.\n"],["to_blob","OpenSSL::PKey::EC::Point","OpenSSL/PKey/EC/Point.html#method-i-to_blob","()","<p>Converts the key to a blob, according to the SSH2 protocol.\n"],["to_blob","OpenSSL::PKey::RSA","OpenSSL/PKey/RSA.html#method-i-to_blob","()","<p>Converts the key to a blob, according to the SSH2 protocol.\n"],["to_i","Net::SSH::Version","Net/SSH/Version.html#method-i-to_i","()","<p>Converts this version to a canonical integer that may be compared against\nother version objects.\n"],["to_pem","Net::SSH::Authentication::Certificate","Net/SSH/Authentication/Certificate.html#method-i-to_pem","()",""],["to_pem","Net::SSH::Authentication::ED25519::PubKey","Net/SSH/Authentication/ED25519/PubKey.html#method-i-to_pem","()",""],["to_s","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-to_s","()","<p>Returns a copy of the buffer&#39;s content.\n"],["to_s","Net::SSH::Test::RemotePacket","Net/SSH/Test/RemotePacket.html#method-i-to_s","()","<p>Returns this remote packet as a string, suitable for parsing by \nNet::SSH::Transport::PacketStream and …\n"],["to_s","Net::SSH::Version","Net/SSH/Version.html#method-i-to_s","()","<p>Converts this version object to a string, where each of the three version\ncomponents are joined by the …\n"],["to_ssh","OpenSSL::BN","OpenSSL/BN.html#method-i-to_ssh","()","<p>Converts a BN object to a string. The format used is that which is required\nby the SSH2 protocol.\n"],["translate","Net::SSH::Config","Net/SSH/Config.html#method-c-translate","(settings)","<p>Given a hash of OpenSSH configuration options, converts them into a hash of\nNet::SSH options. Unrecognized …\n"],["transport","Net::SSH::Test","Net/SSH/Test.html#method-i-transport","(options={})","<p>Returns the transport session (Net::SSH::Transport::Session) for use in\nthese tests. It is a fully functional …\n"],["types","Net::SSH::Test::Packet","Net/SSH/Test/Packet.html#method-i-types","()","<p>Returns an array of symbols describing the data elements for packets of the\nsame type as this packet. …\n"],["update","Net::SSH::Transport::CTR","Net/SSH/Transport/CTR.html#method-i-update","(data)",""],["update","Net::SSH::Transport::IdentityCipher","Net/SSH/Transport/IdentityCipher.html#method-c-update","(text)","<p>Passes its single argument through unchanged.\n"],["update_cipher","Net::SSH::Transport::State","Net/SSH/Transport/State.html#method-i-update_cipher","(data)",""],["use_agent=","Net::SSH::Authentication::KeyManager","Net/SSH/Authentication/KeyManager.html#method-i-use_agent-3D","(use_agent)","<p>Toggles whether the ssh-agent will be used or not. If true, an attempt will\nbe made to use the ssh-agent. …\n"],["use_agent?","Net::SSH::Authentication::KeyManager","Net/SSH/Authentication/KeyManager.html#method-i-use_agent-3F","()","<p>Identifies whether the ssh-agent will be used or not.\n"],["userauth_request","Net::SSH::Authentication::Methods::Abstract","Net/SSH/Authentication/Methods/Abstract.html#method-i-userauth_request","(username, next_service, auth_method, *others)","<p>Creates a new USERAUTH_REQUEST packet. The extra arguments on the end must\nbe either boolean values or …\n"],["valid?","OpenSSL::PKey::DH","OpenSSL/PKey/DH.html#method-i-valid-3F","()","<p>Determines whether the pub_key for this key is valid. (This algorithm\nlifted more-or-less directly from …\n"],["verify","Net::SSH::Transport::Session::CompatibleVerifier","Net/SSH/Transport/Session/CompatibleVerifier.html#method-i-verify","(arguments)",""],["verify","Net::SSH::Verifiers::AcceptNew","Net/SSH/Verifiers/AcceptNew.html#method-i-verify","(arguments)",""],["verify","Net::SSH::Verifiers::AcceptNewOrLocalTunnel","Net/SSH/Verifiers/AcceptNewOrLocalTunnel.html#method-i-verify","(arguments)","<p>Tries to determine if the connection is being tunnelled, and if so, returns\ntrue. Otherwise, performs …\n"],["verify","Net::SSH::Verifiers::Always","Net/SSH/Verifiers/Always.html#method-i-verify","(arguments)",""],["verify","Net::SSH::Verifiers::Never","Net/SSH/Verifiers/Never.html#method-i-verify","(arguments)","<p>Returns true.\n"],["verify_signature","Net::SSH::Transport::Session::CompatibleVerifier","Net/SSH/Transport/Session/CompatibleVerifier.html#method-i-verify_signature","(&block)",""],["verify_signature","Net::SSH::Verifiers::AcceptNew","Net/SSH/Verifiers/AcceptNew.html#method-i-verify_signature","(&block)",""],["verify_signature","Net::SSH::Verifiers::Always","Net/SSH/Verifiers/Always.html#method-i-verify_signature","(&block)",""],["verify_signature","Net::SSH::Verifiers::Never","Net/SSH/Verifiers/Never.html#method-i-verify_signature","(&block)",""],["wait","Net::SSH::Connection::Channel","Net/SSH/Connection/Channel.html#method-i-wait","()","<p>Runs the SSH event loop until the channel is no longer active. This is\nhandy for blocking while you wait …\n"],["wait","Net::SSH::Transport::Session","Net/SSH/Transport/Session.html#method-i-wait","()","<p>Waits (blocks) until the given block returns true. If no block is given,\nthis just waits long enough …\n"],["wait_for_pending_sends","Net::SSH::BufferedIo","Net/SSH/BufferedIo.html#method-i-wait_for_pending_sends","()","<p>Calls #send_pending repeatedly, if necessary, blocking until the output\nbuffer is empty.\n"],["with_test_extension","Net::SSH::Test::Extensions::IO","Net/SSH/Test/Extensions/IO.html#method-c-with_test_extension","(&block)",""],["write","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-write","(*data)","<p>Writes the given data literally into the string. Does not alter the read\nposition. Returns the buffer …\n"],["write","Net::SSH::Test::Socket","Net/SSH/Test/Socket.html#method-i-write","(data)","<p>This doesn&#39;t actually do anything, since we don&#39;t really care what\ngets written.\n"],["write_bignum","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-write_bignum","(*n)","<p>Writes each argument to the buffer as a bignum (SSH2-style). No checking is\ndone to ensure that the arguments …\n"],["write_bool","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-write_bool","(*b)","<p>Writes each argument to the buffer as a (C-style) boolean, with 1 meaning\ntrue, and 0 meaning false. …\n"],["write_byte","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-write_byte","(*n)","<p>Writes each argument to the buffer as a byte. Does not alter the read\nposition. Returns the buffer object. …\n"],["write_int64","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-write_int64","(*n)","<p>Writes each argument to the buffer as a network-byte-order-encoded 64-bit\ninteger (8 bytes). Does not …\n"],["write_key","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-write_key","(*key)","<p>Writes the given arguments to the buffer as SSH2-encoded keys. Does not\nalter the read position. Returns …\n"],["write_long","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-write_long","(*n)","<p>Writes each argument to the buffer as a network-byte-order-encoded long\n(4-byte) integer. Does not alter …\n"],["write_moved","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-write_moved","(string)","<p>Optimized version of write where the caller gives up ownership of string to\nthe method. This way we can …\n"],["write_mstring","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-write_mstring","(*text)","<p>Writes each argument to the buffer as an SSH2-encoded string. Each string\nis prefixed by its length, …\n"],["write_string","Net::SSH::Buffer","Net/SSH/Buffer.html#method-i-write_string","(*text)","<p>Writes each argument to the buffer as an SSH2-encoded string. Each string\nis prefixed by its length, …\n"],["xor!","Net::SSH::Transport::CTR","Net/SSH/Transport/CTR.html#method-i-xor-21","(s1, s2)",""],["CHANGES","","CHANGES_txt.html","","<p>6.0.0 beta1\n\n<pre>* curve25519sha256 support [Florian Wininger ,#690]\n* disabled insecure algs [Florian Wininger ...</pre>\n"],["LICENSE","","LICENSE_txt.html","","<p>Copyright © 2008 Jamis Buck\n<p>Permission is hereby granted, free of charge, to any person obtaining a\ncopy …\n"],["README","","README_md.html","","<p><img src=\"https://badge.fury.io/rb/net-ssh.svg\">\n<img\nsrc=\"https://badges.gitter.im/net-ssh/net-ssh.svg\"> ...\n"],["THANKS","","THANKS_txt.html","","<p>Net::SSH was originally written by Jamis Buck &lt;jamis@37signals.com&gt;.\nIt is currently maintained …\n"]]}}