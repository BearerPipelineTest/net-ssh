<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class Net::SSH::Connection::Channel - net-ssh 6.0.0.beta1</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../../";
  var index_rel_prefix = "../../../";
</script>

<script src="../../../js/jquery.js"></script>
<script src="../../../js/darkfish.js"></script>

<link href="../../../css/fonts.css" rel="stylesheet">
<link href="../../../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../../table_of_contents.html#pages">Pages</a>
    <a href="../../../table_of_contents.html#classes">Classes</a>
    <a href="../../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link">Object
  
</div>

    <div id="includes-section" class="nav-section">
  <h3>Included Modules</h3>

  <ul class="link-list">
  
  
    <li><a class="include" href="../Loggable.html">Net::SSH::Loggable</a>
  
  
  
    <li><a class="include" href="Constants.html">Net::SSH::Connection::Constants</a>
  
  
  </ul>
</div>

    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-i-5B-5D">#[]</a>
    
    <li ><a href="#method-i-5B-5D-3D">#[]=</a>
    
    <li ><a href="#method-i-active-3F">#active?</a>
    
    <li ><a href="#method-i-close">#close</a>
    
    <li ><a href="#method-i-closing-3F">#closing?</a>
    
    <li ><a href="#method-i-do_close">#do_close</a>
    
    <li ><a href="#method-i-do_eof">#do_eof</a>
    
    <li ><a href="#method-i-do_extended_data">#do_extended_data</a>
    
    <li ><a href="#method-i-do_failure">#do_failure</a>
    
    <li ><a href="#method-i-do_open_failed">#do_open_failed</a>
    
    <li ><a href="#method-i-do_success">#do_success</a>
    
    <li ><a href="#method-i-env">#env</a>
    
    <li ><a href="#method-i-eof-21">#eof!</a>
    
    <li ><a href="#method-i-eof-3F">#eof?</a>
    
    <li ><a href="#method-i-exec">#exec</a>
    
    <li ><a href="#method-i-local_closed-3F">#local_closed?</a>
    
    <li ><a href="#method-i-on_close">#on_close</a>
    
    <li ><a href="#method-i-on_data">#on_data</a>
    
    <li ><a href="#method-i-on_eof">#on_eof</a>
    
    <li ><a href="#method-i-on_extended_data">#on_extended_data</a>
    
    <li ><a href="#method-i-on_open_failed">#on_open_failed</a>
    
    <li ><a href="#method-i-on_process">#on_process</a>
    
    <li ><a href="#method-i-on_request">#on_request</a>
    
    <li ><a href="#method-i-process">#process</a>
    
    <li ><a href="#method-i-remote_closed-21">#remote_closed!</a>
    
    <li ><a href="#method-i-remote_closed-3F">#remote_closed?</a>
    
    <li ><a href="#method-i-request_pty">#request_pty</a>
    
    <li ><a href="#method-i-send_channel_request">#send_channel_request</a>
    
    <li ><a href="#method-i-send_data">#send_data</a>
    
    <li ><a href="#method-i-subsystem">#subsystem</a>
    
    <li ><a href="#method-i-wait">#wait</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-Net::SSH::Connection::Channel">
  <h1 id="class-Net::SSH::Connection::Channel" class="class">
    class Net::SSH::Connection::Channel
  </h1>

  <section class="description">
    
<p>The channel abstraction. Multiple “channels” can be multiplexed onto a
single <a href="../../SSH.html">SSH</a> channel, each operating
independently and seemingly in parallel. This class represents a single
such channel. Most operations performed with the <a
href="../../SSH.html">Net::SSH</a> library will involve using one or more
channels.</p>

<p>Channels are intended to be used asynchronously. You request that one be
opened (via <a
href="Session.html#method-i-open_channel">Net::SSH::Connection::Session#open_channel</a>),
and when it is opened, your callback is invoked. Then, you set various
other callbacks on the newly opened channel, which are called in response
to the corresponding events. Programming with <a
href="../../SSH.html">Net::SSH</a> works best if you think of your programs
as state machines. Complex programs are best implemented as objects that
wrap a channel. See Net::SCP and Net::SFTP for examples of how complex
state machines can be built on top of the <a href="../../SSH.html">SSH</a>
protocol.</p>

<pre class="ruby"><span class="ruby-identifier">ssh</span>.<span class="ruby-identifier">open_channel</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">channel</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">exec</span>(<span class="ruby-string">&quot;/invoke/some/command&quot;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span>, <span class="ruby-identifier">success</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">abort</span> <span class="ruby-string">&quot;could not execute command&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">success</span>

    <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">on_data</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span>, <span class="ruby-identifier">data</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;got stdout: #{data}&quot;</span>
      <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">send_data</span> <span class="ruby-string">&quot;something for stdin\n&quot;</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">on_extended_data</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span>, <span class="ruby-identifier">type</span>, <span class="ruby-identifier">data</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;got stderr: #{data}&quot;</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">on_close</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;channel is closing!&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">ssh</span>.<span class="ruby-identifier">loop</span>
</pre>

<p>Channels also have a basic hash-like interface, that allows programs to
store arbitrary state information on a channel object. This helps simplify
the writing of state machines, especially when you may be juggling multiple
open channels at the same time.</p>

<p>Note that data sent across <a href="../../SSH.html">SSH</a> channels are
governed by maximum packet sizes and maximum window sizes. These details
are managed internally by <a
href="Channel.html">Net::SSH::Connection::Channel</a>, so you may remain
blissfully ignorant if you so desire, but you can always inspect the
current maximums, as well as the remaining window size, using the reader
attributes for those values.</p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
      
        <dt id="GOOD_LOCAL_MAXIUMUM_WINDOW_SIZE">GOOD_LOCAL_MAXIUMUM_WINDOW_SIZE
        
        <dd>
        
      
        <dt id="LOCAL_WINDOW_SIZE_INCREMENT">LOCAL_WINDOW_SIZE_INCREMENT
        
        <dd>
        
      
        <dt id="VALID_PTY_OPTIONS">VALID_PTY_OPTIONS
        
        <dd><p>A hash of the valid PTY options (see <a
href="Channel.html#method-i-request_pty">request_pty</a>).</p>
        
      
      </dl>
    </section>
    

    
    <section class="attribute-method-details" class="method-section">
      <header>
        <h3>Attributes</h3>
      </header>

      
      <div id="attribute-i-connection" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">connection</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>The underlying <a href="Session.html">Net::SSH::Connection::Session</a>
instance that supports this channel.</p>
        
        </div>
      </div>
      
      <div id="attribute-i-local_id" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">local_id</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>The local id for this channel, assigned by the <a
href="Session.html">Net::SSH::Connection::Session</a> instance.</p>
        
        </div>
      </div>
      
      <div id="attribute-i-local_maximum_packet_size" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">local_maximum_packet_size</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>The maximum packet size that the local host can receive.</p>
        
        </div>
      </div>
      
      <div id="attribute-i-local_maximum_window_size" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">local_maximum_window_size</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>The maximum amount of data that the local end of this channel can receive.
This is a total, not per-packet.</p>
        
        </div>
      </div>
      
      <div id="attribute-i-local_window_size" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">local_window_size</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>This is the remaining window size on the local end of this channel. When
this reaches zero, no more data can be received.</p>
        
        </div>
      </div>
      
      <div id="attribute-i-properties" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">properties</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>A hash of properties for this channel. These can be used to store state
information about this channel. See also <a
href="Channel.html#method-i-5B-5D">[]</a> and <a
href="Channel.html#method-i-5B-5D-3D">[]=</a>.</p>
        
        </div>
      </div>
      
      <div id="attribute-i-remote_id" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">remote_id</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>The remote id for this channel, assigned by the remote host.</p>
        
        </div>
      </div>
      
      <div id="attribute-i-remote_maximum_packet_size" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">remote_maximum_packet_size</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>The maximum packet size that the remote host can receive.</p>
        
        </div>
      </div>
      
      <div id="attribute-i-remote_maximum_window_size" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">remote_maximum_window_size</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>The maximum amount of data that the remote end of this channel can receive.
This is a total, not per-packet.</p>
        
        </div>
      </div>
      
      <div id="attribute-i-remote_window_size" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">remote_window_size</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>This is the remaining window size on the remote end of this channel. When
this reaches zero, no more data can be sent.</p>
        
        </div>
      </div>
      
      <div id="attribute-i-type" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">type</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>The type of this channel, usually “session”.</p>
        
        </div>
      </div>
      
    </section>
    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">(connection, type, local_id, max_pkt_size = 0x8000, max_win_size = 0x20000, &on_confirm_open)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Instantiates a new channel on the given connection, of the given type, and
with the given id. If a block is given, it will be remembered until the
channel is confirmed open by the server, and will be invoked at that time
(see do_open_confirmation).</p>

<p>This also sets the default maximum packet size and maximum window size.</p>
          
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">connection</span>, <span class="ruby-identifier">type</span>, <span class="ruby-identifier">local_id</span>, <span class="ruby-identifier">max_pkt_size</span> = <span class="ruby-value">0x8000</span>, <span class="ruby-identifier">max_win_size</span> = <span class="ruby-value">0x20000</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">on_confirm_open</span>)
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">logger</span> = <span class="ruby-identifier">connection</span>.<span class="ruby-identifier">logger</span>
    
  <span class="ruby-ivar">@connection</span> = <span class="ruby-identifier">connection</span>
  <span class="ruby-ivar">@type</span>       = <span class="ruby-identifier">type</span>
  <span class="ruby-ivar">@local_id</span>   = <span class="ruby-identifier">local_id</span>
    
  <span class="ruby-ivar">@local_maximum_packet_size</span> = <span class="ruby-identifier">max_pkt_size</span>
  <span class="ruby-ivar">@local_window_size</span> = <span class="ruby-ivar">@local_maximum_window_size</span> = <span class="ruby-identifier">max_win_size</span>
    
  <span class="ruby-ivar">@on_confirm_open</span> = <span class="ruby-identifier">on_confirm_open</span>
    
  <span class="ruby-ivar">@output</span> = <span class="ruby-constant">Buffer</span>.<span class="ruby-identifier">new</span>
    
  <span class="ruby-ivar">@properties</span> = {}
    
  <span class="ruby-ivar">@pending_requests</span> = []
  <span class="ruby-ivar">@on_open_failed</span> = <span class="ruby-ivar">@on_data</span> = <span class="ruby-ivar">@on_extended_data</span> = <span class="ruby-ivar">@on_process</span> = <span class="ruby-ivar">@on_close</span> = <span class="ruby-ivar">@on_eof</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@on_request</span> = {}
  <span class="ruby-ivar">@closing</span> = <span class="ruby-ivar">@eof</span> = <span class="ruby-ivar">@sent_eof</span> = <span class="ruby-ivar">@local_closed</span> = <span class="ruby-ivar">@remote_closed</span> = <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-5B-5D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">[]</span><span
            class="method-args">(name)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>A shortcut for accessing properties of the channel (see <a
href="Channel.html#attribute-i-properties">properties</a>).</p>
          
          

          
          <div class="method-source-code" id="5B-5D-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 136</span>
<span class="ruby-keyword">def</span> <span class="ruby-operator">[]</span>(<span class="ruby-identifier">name</span>)
  <span class="ruby-ivar">@properties</span>[<span class="ruby-identifier">name</span>]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-5B-5D-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">[]=</span><span
            class="method-args">(name, value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>A shortcut for setting properties of the channel (see <a
href="Channel.html#attribute-i-properties">properties</a>).</p>
          
          

          
          <div class="method-source-code" id="5B-5D-3D-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 141</span>
<span class="ruby-keyword">def</span> <span class="ruby-operator">[]=</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">value</span>)
  <span class="ruby-ivar">@properties</span>[<span class="ruby-identifier">name</span>] = <span class="ruby-identifier">value</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-active-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">active?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns true if the channel exists in the channel list of the session, and
false otherwise. This can be used to determine whether a channel has been
closed or not.</p>

<pre class="ruby"><span class="ruby-identifier">ssh</span>.<span class="ruby-identifier">loop</span> { <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">active?</span> }
</pre>
          
          

          
          <div class="method-source-code" id="active-3F-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 262</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">active?</span>
  <span class="ruby-identifier">connection</span>.<span class="ruby-identifier">channels</span>.<span class="ruby-identifier">key?</span>(<span class="ruby-identifier">local_id</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-close" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">close</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Requests that the channel be closed. It only marks the channel to be closed
the CHANNEL_CLOSE message will be sent from event loop</p>
          
          

          
          <div class="method-source-code" id="close-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 299</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">close</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@closing</span>
  <span class="ruby-ivar">@closing</span> = <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-closing-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">closing?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>True if close() has been called; NOTE: if the channel has data waiting to
be sent then the channel will close after all the data is sent. See
closed?() to determine if we have actually sent CHANNEL_CLOSE to server.
This may be true for awhile before closed? returns true if we are still
sending buffered output to server.</p>
          
          

          
          <div class="method-source-code" id="closing-3F-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 280</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">closing?</span>
  <span class="ruby-ivar">@closing</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-do_close" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">do_close</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Invokes the <a href="Channel.html#method-i-on_close">on_close</a> callback
when the server closes a channel. The channel is the only argument.</p>
          
          

          
          <div class="method-source-code" id="do_close-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 609</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">do_close</span>
  <span class="ruby-ivar">@on_close</span>.<span class="ruby-identifier">call</span>(<span class="ruby-keyword">self</span>) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@on_close</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-do_eof" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">do_eof</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Invokes the <a href="Channel.html#method-i-on_eof">on_eof</a> callback when
the server indicates that no further data is forthcoming. The callback is
invoked with the channel as the argument.</p>
          
          

          
          <div class="method-source-code" id="do_eof-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 603</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">do_eof</span>
  <span class="ruby-ivar">@on_eof</span>.<span class="ruby-identifier">call</span>(<span class="ruby-keyword">self</span>) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@on_eof</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-do_extended_data" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">do_extended_data</span><span
            class="method-args">(type, data)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Invokes the <a
href="Channel.html#method-i-on_extended_data">on_extended_data</a> callback
when the server sends extended data to the channel. This will reduce the
available window size on the local end. The callback is invoked with the
channel, type, and data.</p>
          
          

          
          <div class="method-source-code" id="do_extended_data-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 595</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">do_extended_data</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">data</span>)
  <span class="ruby-identifier">update_local_window_size</span>(<span class="ruby-identifier">data</span>.<span class="ruby-identifier">length</span>)
  <span class="ruby-ivar">@on_extended_data</span>.<span class="ruby-identifier">call</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">type</span>, <span class="ruby-identifier">data</span>) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@on_extended_data</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-do_failure" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">do_failure</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Invokes the next pending request callback with <code>false</code> as the
second argument.</p>
          
          

          
          <div class="method-source-code" id="do_failure-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 615</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">do_failure</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">callback</span> = <span class="ruby-identifier">pending_requests</span>.<span class="ruby-identifier">shift</span>
    <span class="ruby-identifier">callback</span>.<span class="ruby-identifier">call</span>(<span class="ruby-keyword">self</span>, <span class="ruby-keyword">false</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">error</span> { <span class="ruby-string">&quot;channel failure received with no pending request to handle it (bug?)&quot;</span> }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-do_open_failed" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">do_open_failed</span><span
            class="method-args">(reason_code, description)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Invoked when the server failed to open the channel. If an <a
href="Channel.html#method-i-on_open_failed">on_open_failed</a> callback was
specified, it will be invoked with the channel, reason code, and
description as arguments. Otherwise, a <a
href="../ChannelOpenFailed.html">ChannelOpenFailed</a> exception will be
raised.</p>
          
          

          
          <div class="method-source-code" id="do_open_failed-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 540</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">do_open_failed</span>(<span class="ruby-identifier">reason_code</span>, <span class="ruby-identifier">description</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@on_open_failed</span>
    <span class="ruby-ivar">@on_open_failed</span>.<span class="ruby-identifier">call</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">reason_code</span>, <span class="ruby-identifier">description</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ChannelOpenFailed</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">reason_code</span>, <span class="ruby-identifier">description</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-do_success" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">do_success</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Invokes the next pending request callback with <code>true</code> as the
second argument.</p>
          
          

          
          <div class="method-source-code" id="do_success-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 625</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">do_success</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">callback</span> = <span class="ruby-identifier">pending_requests</span>.<span class="ruby-identifier">shift</span>
    <span class="ruby-identifier">callback</span>.<span class="ruby-identifier">call</span>(<span class="ruby-keyword">self</span>, <span class="ruby-keyword">true</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">error</span> { <span class="ruby-string">&quot;channel success received with no pending request to handle it (bug?)&quot;</span> }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-env" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">env</span><span
            class="method-args">(variable_name, variable_value, &block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Syntactic sugar for setting an environment variable in the remote
process&#39; environment. Note that for security reasons, the server may
refuse to set certain environment variables, or all, at the server&#39;s
discretion. If you are connecting to an OpenSSH server, you will need to
update the AcceptEnv setting in the sshd_config to include the environment
variables you want to send.</p>

<pre class="ruby"><span class="ruby-identifier">channel</span>.<span class="ruby-identifier">env</span> <span class="ruby-string">&quot;PATH&quot;</span>, <span class="ruby-string">&quot;/usr/local/bin&quot;</span>
</pre>
          
          

          
          <div class="method-source-code" id="env-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 190</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">env</span>(<span class="ruby-identifier">variable_name</span>, <span class="ruby-identifier">variable_value</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">send_channel_request</span>(<span class="ruby-string">&quot;env&quot;</span>, <span class="ruby-value">:string</span>, <span class="ruby-identifier">variable_name</span>, <span class="ruby-value">:string</span>, <span class="ruby-identifier">variable_value</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-eof-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">eof!</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Tells the remote end of the channel that no more data is forthcoming from
this end of the channel. The remote end may still send data. The
CHANNEL_EOF packet will be sent once the output buffer is empty.</p>
          
          

          
          <div class="method-source-code" id="eof-21-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 314</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">eof!</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">eof?</span>
  <span class="ruby-ivar">@eof</span> = <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-eof-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">eof?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns true if the local end of the channel has declared that no more data
is forthcoming (see <a href="Channel.html#method-i-eof-21">eof!</a>).
Trying to send data via <a
href="Channel.html#method-i-send_data">send_data</a> when this is true will
result in an exception being raised.</p>
          
          

          
          <div class="method-source-code" id="eof-3F-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 307</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">eof?</span>
  <span class="ruby-ivar">@eof</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-exec" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">exec</span><span
            class="method-args">(command, &block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Syntactic sugar for executing a command. Sends a channel request asking
that the given command be invoked. If the block is given, it will be called
when the server responds. The first parameter will be the channel, and the
second will be true or false, indicating whether the request succeeded or
not. In this case, success means that the command is being executed, not
that it has completed, and failure means that the command altogether failed
to be executed.</p>

<pre class="ruby"><span class="ruby-identifier">channel</span>.<span class="ruby-identifier">exec</span> <span class="ruby-string">&quot;ls -l /home&quot;</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span>, <span class="ruby-identifier">success</span><span class="ruby-operator">|</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">success</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;command has begun executing...&quot;</span>
    <span class="ruby-comment"># this is a good place to hang callbacks like #on_data...</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;alas! the command could not be invoked!&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>
          
          

          
          <div class="method-source-code" id="exec-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">exec</span>(<span class="ruby-identifier">command</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">send_channel_request</span>(<span class="ruby-string">&quot;exec&quot;</span>, <span class="ruby-value">:string</span>, <span class="ruby-identifier">command</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-local_closed-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">local_closed?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>True if we have sent CHANNEL_CLOSE to the remote server.</p>
          
          

          
          <div class="method-source-code" id="local_closed-3F-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 285</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">local_closed?</span>
  <span class="ruby-ivar">@local_closed</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_close" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">on_close</span><span
            class="method-args">(&block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Registers a callback to be invoked when the server acknowledges that a
channel is closed. This is invoked with the channel as the sole argument.</p>

<pre class="ruby"><span class="ruby-identifier">channel</span>.<span class="ruby-identifier">on_close</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;remote end is closing!&quot;</span>
<span class="ruby-keyword">end</span>
</pre>
          
          

          
          <div class="method-source-code" id="on_close-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 401</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">on_close</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">old</span>, <span class="ruby-ivar">@on_close</span> = <span class="ruby-ivar">@on_close</span>, <span class="ruby-identifier">block</span>
  <span class="ruby-identifier">old</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_data" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">on_data</span><span
            class="method-args">(&block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Registers a callback to be invoked when data packets are received by the
channel. The callback is called with the channel as the first argument, and
the data as the second.</p>

<pre class="ruby"><span class="ruby-identifier">channel</span>.<span class="ruby-identifier">on_data</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span>, <span class="ruby-identifier">data</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;got data: #{data.inspect}&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Data received this way is typically the data written by the remote process
to its <code>stdout</code> stream.</p>
          
          

          
          <div class="method-source-code" id="on_data-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 348</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">on_data</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">old</span>, <span class="ruby-ivar">@on_data</span> = <span class="ruby-ivar">@on_data</span>, <span class="ruby-identifier">block</span>
  <span class="ruby-identifier">old</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_eof" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">on_eof</span><span
            class="method-args">(&block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Registers a callback to be invoked when the server indicates that no more
data will be sent to the channel (although the channel can still send data
to the server). The channel is the sole argument to the callback.</p>

<pre class="ruby"><span class="ruby-identifier">channel</span>.<span class="ruby-identifier">on_eof</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;remote end is done sending data&quot;</span>
<span class="ruby-keyword">end</span>
</pre>
          
          

          
          <div class="method-source-code" id="on_eof-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 413</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">on_eof</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">old</span>, <span class="ruby-ivar">@on_eof</span> = <span class="ruby-ivar">@on_eof</span>, <span class="ruby-identifier">block</span>
  <span class="ruby-identifier">old</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_extended_data" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">on_extended_data</span><span
            class="method-args">(&block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Registers a callback to be invoked when extended data packets are received
by the channel. The callback is called with the channel as the first
argument, the data type (as an integer) as the second, and the data as the
third. Extended data is almost exclusively used to send <code>stderr</code>
data (<code>type</code> == 1). Other extended data types are not defined by
the <a href="../../SSH.html">SSH</a> protocol.</p>

<pre class="ruby"><span class="ruby-identifier">channel</span>.<span class="ruby-identifier">on_extended_data</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span>, <span class="ruby-identifier">type</span>, <span class="ruby-identifier">data</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;got stderr: #{data.inspect}&quot;</span>
<span class="ruby-keyword">end</span>
</pre>
          
          

          
          <div class="method-source-code" id="on_extended_data-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 363</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">on_extended_data</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">old</span>, <span class="ruby-ivar">@on_extended_data</span> = <span class="ruby-ivar">@on_extended_data</span>, <span class="ruby-identifier">block</span>
  <span class="ruby-identifier">old</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_open_failed" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">on_open_failed</span><span
            class="method-args">(&block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Registers a callback to be invoked when the server was unable to open the
requested channel. The channel itself will be passed to the block, along
with the integer “reason code” for the failure, and a textual description
of the failure from the server.</p>

<pre>channel = session.open_channel do |ch|
  # ..
end

channel.on_open_failed { |ch, code, desc| ... }</pre>
          
          

          
          <div class="method-source-code" id="on_open_failed-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 428</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">on_open_failed</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">old</span>, <span class="ruby-ivar">@on_open_failed</span> = <span class="ruby-ivar">@on_open_failed</span>, <span class="ruby-identifier">block</span>
  <span class="ruby-identifier">old</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_process" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">on_process</span><span
            class="method-args">(&block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Registers a callback to be invoked for each pass of the event loop for this
channel. There are no guarantees on timeliness in the event loop, but it
will be called roughly once for each packet received by the connection (not
the channel). This callback is invoked with the channel as the sole
argument.</p>

<p>Here&#39;s an example that accumulates the channel data into a variable on
the channel itself, and displays individual lines in the input one at a
time when the channel is processed:</p>

<pre class="ruby"><span class="ruby-identifier">channel</span>[:<span class="ruby-identifier">data</span>] = <span class="ruby-string">&quot;&quot;</span>

<span class="ruby-identifier">channel</span>.<span class="ruby-identifier">on_data</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span>, <span class="ruby-identifier">data</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">channel</span>[:<span class="ruby-identifier">data</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">data</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">channel</span>.<span class="ruby-identifier">on_process</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span><span class="ruby-operator">|</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">channel</span>[:<span class="ruby-identifier">data</span>] <span class="ruby-operator">=~</span> <span class="ruby-regexp">/^.*?\n/</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-node">$&amp;</span>
    <span class="ruby-identifier">channel</span>[:<span class="ruby-identifier">data</span>] = <span class="ruby-node">$&#39;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>
          
          

          
          <div class="method-source-code" id="on_process-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 390</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">on_process</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">old</span>, <span class="ruby-ivar">@on_process</span> = <span class="ruby-ivar">@on_process</span>, <span class="ruby-identifier">block</span>
  <span class="ruby-identifier">old</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_request" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">on_request</span><span
            class="method-args">(type, &block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Registers a callback to be invoked when a channel request of the given type
is received. The callback will receive the channel as the first argument,
and the associated (unparsed) data as the second. The data will be a <a
href="../Buffer.html">Net::SSH::Buffer</a> that you will need to parse,
yourself, according to the kind of request you are watching.</p>

<p>By default, if the request wants a reply, <a
href="../../SSH.html">Net::SSH</a> will send a CHANNEL_SUCCESS response for
any request that was handled by a registered callback, and CHANNEL_FAILURE
for any that wasn&#39;t, but if you want your registered callback to result
in a CHANNEL_FAILURE response, just raise <a
href="../ChannelRequestFailed.html">Net::SSH::ChannelRequestFailed</a>.</p>

<p>Some common channel requests that your programs might want to listen for
are:</p>
<ul><li>
<p>“exit-status” : the exit status of the remote process will be reported as a
long integer in the data buffer, which you can grab via data.read_long.</p>
</li><li>
<p>“exit-signal” : if the remote process died as a result of a signal being
sent to it, the signal will be reported as a string in the data, via
data.read_string. (Not all <a href="../../SSH.html">SSH</a> servers support
this channel request type.)</p>

<pre class="ruby"><span class="ruby-identifier">channel</span>.<span class="ruby-identifier">on_request</span> <span class="ruby-string">&quot;exit-status&quot;</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span>, <span class="ruby-identifier">data</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;process terminated with exit status: #{data.read_long}&quot;</span>
<span class="ruby-keyword">end</span>
</pre>
</li></ul>
          
          

          
          <div class="method-source-code" id="on_request-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 459</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">on_request</span>(<span class="ruby-identifier">type</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">old</span>, <span class="ruby-ivar">@on_request</span>[<span class="ruby-identifier">type</span>] = <span class="ruby-ivar">@on_request</span>[<span class="ruby-identifier">type</span>], <span class="ruby-identifier">block</span>
  <span class="ruby-identifier">old</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-process" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">process</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>If an <a href="Channel.html#method-i-on_process">on_process</a> handler has
been set up, this will cause it to be invoked (passing the channel itself
as an argument). It also causes all pending output to be enqueued as
CHANNEL_DATA packets (see enqueue_pending_output).</p>
          
          

          
          <div class="method-source-code" id="process-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 322</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">process</span>
  <span class="ruby-ivar">@on_process</span>.<span class="ruby-identifier">call</span>(<span class="ruby-keyword">self</span>) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@on_process</span>
  <span class="ruby-identifier">enqueue_pending_output</span>
    
  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@eof</span> <span class="ruby-keyword">and</span> <span class="ruby-keyword">not</span> <span class="ruby-ivar">@sent_eof</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">output</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">remote_id</span> <span class="ruby-keyword">and</span> <span class="ruby-keyword">not</span> <span class="ruby-ivar">@local_closed</span>
    <span class="ruby-identifier">connection</span>.<span class="ruby-identifier">send_message</span>(<span class="ruby-constant">Buffer</span>.<span class="ruby-identifier">from</span>(<span class="ruby-value">:byte</span>, <span class="ruby-constant">CHANNEL_EOF</span>, <span class="ruby-value">:long</span>, <span class="ruby-identifier">remote_id</span>))
    <span class="ruby-ivar">@sent_eof</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">end</span>
    
  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@closing</span> <span class="ruby-keyword">and</span> <span class="ruby-keyword">not</span> <span class="ruby-ivar">@local_closed</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">output</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">remote_id</span>
    <span class="ruby-identifier">connection</span>.<span class="ruby-identifier">send_message</span>(<span class="ruby-constant">Buffer</span>.<span class="ruby-identifier">from</span>(<span class="ruby-value">:byte</span>, <span class="ruby-constant">CHANNEL_CLOSE</span>, <span class="ruby-value">:long</span>, <span class="ruby-identifier">remote_id</span>))
    <span class="ruby-ivar">@local_closed</span> = <span class="ruby-keyword">true</span>
    <span class="ruby-identifier">connection</span>.<span class="ruby-identifier">cleanup_channel</span>(<span class="ruby-keyword">self</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-remote_closed-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">remote_closed!</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="remote_closed-21-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 293</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">remote_closed!</span>
  <span class="ruby-ivar">@remote_closed</span> = <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-remote_closed-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">remote_closed?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="remote_closed-3F-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 289</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">remote_closed?</span>
  <span class="ruby-ivar">@remote_closed</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-request_pty" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">request_pty</span><span
            class="method-args">(opts={}, &block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Requests that a pseudo-tty (or “pty”) be made available for this channel.
This is useful when you want to invoke and interact with some kind of
screen-based program (e.g., vim, or some menuing system).</p>

<p>Note, that without a pty some programs (e.g. sudo, or subversion) on some
systems, will not be able to run interactively, and will error instead of
prompt if they ever need some user interaction.</p>

<p>Note, too, that when a pty is requested, user&#39;s shell configuration
scripts (.bashrc and such) are not run by default, whereas they are run
when a pty is not present.</p>

<pre class="ruby"><span class="ruby-identifier">channel</span>.<span class="ruby-identifier">request_pty</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span>, <span class="ruby-identifier">success</span><span class="ruby-operator">|</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">success</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;pty successfully obtained&quot;</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;could not obtain pty&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>
          
          

          
          <div class="method-source-code" id="request_pty-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 221</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">request_pty</span>(<span class="ruby-identifier">opts</span>={}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">extra</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">keys</span> <span class="ruby-operator">-</span> <span class="ruby-constant">VALID_PTY_OPTIONS</span>.<span class="ruby-identifier">keys</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-node">&quot;invalid option(s) to request_pty: #{extra.inspect}&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">extra</span>.<span class="ruby-identifier">any?</span>
    
  <span class="ruby-identifier">opts</span> = <span class="ruby-constant">VALID_PTY_OPTIONS</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>)
    
  <span class="ruby-identifier">modes</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:modes</span>].<span class="ruby-identifier">inject</span>(<span class="ruby-constant">Buffer</span>.<span class="ruby-identifier">new</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">memo</span>, (<span class="ruby-identifier">mode</span>, <span class="ruby-identifier">data</span>)<span class="ruby-operator">|</span>
    <span class="ruby-identifier">memo</span>.<span class="ruby-identifier">write_byte</span>(<span class="ruby-identifier">mode</span>).<span class="ruby-identifier">write_long</span>(<span class="ruby-identifier">data</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment"># mark the end of the mode opcode list with a 0 byte</span>
  <span class="ruby-identifier">modes</span>.<span class="ruby-identifier">write_byte</span>(<span class="ruby-value">0</span>)
    
  <span class="ruby-identifier">send_channel_request</span>(<span class="ruby-string">&quot;pty-req&quot;</span>, <span class="ruby-value">:string</span>, <span class="ruby-identifier">opts</span>[<span class="ruby-value">:term</span>],
    <span class="ruby-value">:long</span>, <span class="ruby-identifier">opts</span>[<span class="ruby-value">:chars_wide</span>], <span class="ruby-value">:long</span>, <span class="ruby-identifier">opts</span>[<span class="ruby-value">:chars_high</span>],
    <span class="ruby-value">:long</span>, <span class="ruby-identifier">opts</span>[<span class="ruby-value">:pixels_wide</span>], <span class="ruby-value">:long</span>, <span class="ruby-identifier">opts</span>[<span class="ruby-value">:pixels_high</span>],
    <span class="ruby-value">:string</span>, <span class="ruby-identifier">modes</span>.<span class="ruby-identifier">to_s</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-send_channel_request" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">send_channel_request</span><span
            class="method-args">(request_name, *data, &callback)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Sends a new channel request with the given name. The extra
<code>data</code> parameter must either be empty, or consist of an even
number of arguments. See <a
href="../Buffer.html#method-c-from">Net::SSH::Buffer.from</a> for a
description of their format. If a block is given, it is registered as a
callback for a pending request, and the packet will be flagged so that the
server knows a reply is required. If no block is given, the server will
send no response to this request. Responses, where required, will cause the
callback to be invoked with the channel as the first argument, and either
true or false as the second, depending on whether the request succeeded or
not. The meaning of “success” and “failure” in this context is dependent on
the specific request that was sent.</p>

<pre class="ruby"><span class="ruby-identifier">channel</span>.<span class="ruby-identifier">send_channel_request</span> <span class="ruby-string">&quot;shell&quot;</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span>, <span class="ruby-identifier">success</span><span class="ruby-operator">|</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">success</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;user shell started successfully&quot;</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;could not start user shell&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Most channel requests you&#39;ll want to send are already wrapped in more
convenient helper methods (see <a
href="Channel.html#method-i-exec">exec</a> and <a
href="Channel.html#method-i-subsystem">subsystem</a>).</p>
          
          

          
          <div class="method-source-code" id="send_channel_request-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 486</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">send_channel_request</span>(<span class="ruby-identifier">request_name</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">data</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>)
  <span class="ruby-identifier">info</span> { <span class="ruby-node">&quot;sending channel request #{request_name.inspect}&quot;</span> }
  <span class="ruby-identifier">fail</span> <span class="ruby-string">&quot;Channel open not yet confirmed, please call send_channel_request(or exec) from block of open_channel&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">remote_id</span>
  <span class="ruby-identifier">msg</span> = <span class="ruby-constant">Buffer</span>.<span class="ruby-identifier">from</span>(<span class="ruby-value">:byte</span>, <span class="ruby-constant">CHANNEL_REQUEST</span>,
    <span class="ruby-value">:long</span>, <span class="ruby-identifier">remote_id</span>, <span class="ruby-value">:string</span>, <span class="ruby-identifier">request_name</span>,
    <span class="ruby-value">:bool</span>, <span class="ruby-operator">!</span><span class="ruby-identifier">callback</span>.<span class="ruby-identifier">nil?</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">data</span>)
  <span class="ruby-identifier">connection</span>.<span class="ruby-identifier">send_message</span>(<span class="ruby-identifier">msg</span>)
  <span class="ruby-identifier">pending_requests</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">callback</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">callback</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-send_data" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">send_data</span><span
            class="method-args">(data)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Sends data to the channel&#39;s remote endpoint. This usually has the
effect of sending the given string to the remote process&#39; stdin stream.
Note that it does not immediately send the data across the channel, but
instead merely appends the given data to the channel&#39;s output buffer,
preparatory to being packaged up and sent out the next time the connection
is accepting data. (A connection might not be accepting data if, for
instance, it has filled its data window and has not yet been resized by the
remote end-point.)</p>

<p>This will raise an exception if the channel has previously declared that no
more data will be sent (see <a
href="Channel.html#method-i-eof-21">eof!</a>).</p>

<pre class="ruby"><span class="ruby-identifier">channel</span>.<span class="ruby-identifier">send_data</span>(<span class="ruby-string">&quot;the password\n&quot;</span>)
</pre>
          
          

          
          <div class="method-source-code" id="send_data-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 252</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">send_data</span>(<span class="ruby-identifier">data</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">EOFError</span>, <span class="ruby-string">&quot;cannot send data if channel has declared eof&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">eof?</span>
  <span class="ruby-identifier">output</span>.<span class="ruby-identifier">append</span>(<span class="ruby-identifier">data</span>.<span class="ruby-identifier">to_s</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-subsystem" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">subsystem</span><span
            class="method-args">(subsystem, &block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Syntactic sugar for requesting that a subsystem be started. Subsystems are
a way for other protocols (like SFTP) to be run, using <a
href="../../SSH.html">SSH</a> as the transport. Generally, you&#39;ll never
need to call this directly unless you are the implementor of something that
consumes an <a href="../../SSH.html">SSH</a> subsystem, like SFTP.</p>

<pre class="ruby"><span class="ruby-identifier">channel</span>.<span class="ruby-identifier">subsystem</span>(<span class="ruby-string">&quot;sftp&quot;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span>, <span class="ruby-identifier">success</span><span class="ruby-operator">|</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">success</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;subsystem successfully started&quot;</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;subsystem could not be started&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>
          
          

          
          <div class="method-source-code" id="subsystem-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 178</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">subsystem</span>(<span class="ruby-identifier">subsystem</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">send_channel_request</span>(<span class="ruby-string">&quot;subsystem&quot;</span>, <span class="ruby-value">:string</span>, <span class="ruby-identifier">subsystem</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-wait" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">wait</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Runs the <a href="../../SSH.html">SSH</a> event loop until the channel is
no longer active. This is handy for blocking while you wait for some
channel to finish.</p>

<pre>channel.exec(&quot;grep ...&quot;) { ... }
channel.wait</pre>
          
          

          
          <div class="method-source-code" id="wait-source">
            <pre><span class="ruby-comment"># File lib/net/ssh/connection/channel.rb, line 271</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">wait</span>
  <span class="ruby-identifier">connection</span>.<span class="ruby-identifier">loop</span> { <span class="ruby-identifier">active?</span> }
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://rdoc.github.io/rdoc">RDoc</a> 5.0.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

